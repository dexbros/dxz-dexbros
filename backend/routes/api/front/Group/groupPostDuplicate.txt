/** @format */

require("dotenv").config();
const express = require("express");
const router = express.Router();
const Multer = require("multer");
const uuid = require("uuid");
const uuidv1 = uuid.v1;
const { Storage } = require("@google-cloud/storage");
const { default: mongoose } = require("mongoose");
const { config } = require("dotenv");
const sharp = require("sharp");
const Aerospike = require("aerospike");
const { getAerospikeClient } = require("../../../../aerospike");
const maps = Aerospike.maps;
const { removeStopwords, eng, fra } = require("stopword");
const now = require("nano-time");

const storage = new Storage({
  projectId: "quiztasy",
  credentials: {
    client_email: "dexbros-upload@quiztasy.iam.gserviceaccount.com",
    private_key:
      "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCxtcYo4lgaK7gh\nV1z3UFRkV2HT28rUjuFKrQrfjEEKkzgZWgwu8V6SzPXPYmGWAFpLtYqgUP28QXoq\nXWCWLYlMcQA2OalnjNiilRy8Yq2Yjj75LPy2rKT8W14Cyr07inZxEWsrs5rS3Ycp\nw3nZnub5dxPXqewrjHPQUx0a5a6UiBDD7YdE1fHAniaxZz18yy9f6nOVWac0m5P2\ntHNgrB+CalwQIf51TCvJrfsPw0hFHHYlTWhA8ATZfPJxAXNLklo/roFr/LmfUnq0\nl1nFPQqTMj5jCOQ8DO5j0zFJvgZ/d0ePN0IOyUxhVH9Qq9oQRh7YqdDcr27Vos4H\nmXkoA36JAgMBAAECggEARyDBUqXdq4PqK/YisJ5HWO4cqsZjNZaGl/QQ0Q77DXeF\nUahYDgXv24QLstjmxDoZ6gmclbQ1Cr+OXRyIxzMsrBrigdGse1TFdLWIDeLVJqVw\nkR0vfRI26wbK5wUsnoM6CuF06sX1ZwbhzZZ+09qlCh5eI8jQTVHnHO/XS2e465uq\nIxMWwGBEy5ZVksWV+/OA+YvQMSMxar0AMvCTf2McoUGw/flxXrg4gnl/brI7p4El\nokYb6MVI38VvlQ87MshosDA4bxSj0IyHXzXHC3vJ4E1Ph1CjbHjtV4YVlLy0qH3K\n41UOEa5OPNSG5rvPAz/oQDjyFw2nuDVGpKRlqGteTQKBgQDy3xvXN7jyVr74r42V\n8H2BtyachzYtESrpLnoM4bHEZ3hzjnGrLSQUMFBleajcs+yCqcvzruW7mG5SNYNU\na7NrzncnGC1SOX5ej4oOOW8/K/cYbpqDP6f3NkKh7Xkb+xcbwuPvB+Sbl1sUNRfB\nyY5iVjr3x7GBo0g62AN52/+bvwKBgQC7UPOX/VoAmIpKXfzR9RX43/JsqIJ9WZdY\nK0ToMwskV2bN71T2u0D0/ryh6R7MeyIF5PgAZSyTFXLrlwm/GFzBXgew/4Hiud0g\n4W/h7UXpCDOWGq/Cik2VbshsCvDiJr05Q9SYEVyOj6702ZkEHNc5p1Jgao4xYKSV\nD3yZqfMXtwKBgAvG+eij0RofTr9sc+czdEKYCQ1KGTxyOqx4Dn8VarNleRfRbn2o\ngLlh5mQlVCTvrKZhaXx1nLpOF/twkN/FITw3FNwWdgwosZIQT9eEvXpIvYC3zFJV\nAeYhAXYst9S9hk9YUglDTrikzEvcjzxcc8Uc/VsKmfb5XgVMeE6udmStAoGAe+4z\nPHwC8CH8XPeSLddZki+Y1QsoSobb+xmlnXsoBANPoTCXpiZ985oWc4kpN2DAQeYb\nrydBNo8aWYS0jhowRD9SF2j1JmySQQ7mVzQE7QjgGI/PeYbHjfad493ZQccfqqOW\nJIZYFno55wWQl4f9Xce2WNQm/8RRH83/QiuPCkECgYEAz9WgZuz9tOF2Nl3qkW4I\naW7ViTE8XiFHMFZIh5LXyER98YUxVVRdNBOJtvlop6KXAIN9g8VzrOHvT34jd057\nEwAO4HDmE71PsdqrwgMCJEYGHhkv/ZXU2Hey0bqV0/ajvkcVN5mHm81j68fdqzB0\niBUDWp6KQ0+9BYstzxlNdbw=\n-----END PRIVATE KEY-----\n",
  },
});
const multer = Multer({
  storage: Multer.memoryStorage(),
  limits: {
    fileSize: 500 * 1024 * 1024,
  },
});
const bucket = storage.bucket("dexbros_files");

// Create Post like route...
router.put("/like/:id", async (req, res) => {
  console.log("EMOJI LIKE");
  const id = req.params.id;
  const client = await getAerospikeClient();
  console.log(req.params.id);
  if (!id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      id
    );

    const post = await client.get(post_key);
    if (post.bins.l_c > 0) {
      console.log("Like count greater than 0");
      const meta = await client.get(post_meta_key);
      if (meta.bins.likes.includes(req.user.handleUn)) {
        console.log("Already like");
        const ops = [Aerospike.lists.removeByValue("likes", req.user.handleUn)];
        client.operate(post_meta_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            const ops = [Aerospike.operations.incr("l_c", -1)];
            client.operate(post_key, ops, async (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                if (meta.bins.likes.length === 1) {
                  const ops = [Aerospike.operations.incr("like", -1)];
                  const data = await client.operate(post_key, ops);
                  return res.status(200).json({ msg: "remove Liked post" });
                } else {
                  return res.status(200).json({ msg: "remove Liked post" });
                }
              }
            });
          }
        });
      } else {
        console.log("Not like");
        if (
          meta.bins.haha.includes(req.user.handleUn) ||
          meta.bins.angry.includes(req.user.handleUn) ||
          meta.bins.dislikes.includes(req.user.handleUn)
        ) {
          console.log("Not like Other");
          const ops = [
            Aerospike.lists.removeByValue("haha", req.user.handleUn),
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
            Aerospike.lists.removeByValue("dislikes", req.user.handleUn),
          ];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.lists.append("likes", req.user.handleUn)];
              client.operate(post_meta_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "You liked this post" });
                  if (meta.bins.likes.length === 0) {
                    const ops = [Aerospike.operations.incr("like", 1)];
                    const data = await client.operate(post_key, ops);

                    return res.status(200).json({ msg: "Liked post" });
                  } else {
                    return res.status(200).json({ msg: "Liked post" });
                  }
                }
              });
            }
          });
        } else {
          const ops = [Aerospike.lists.append("likes", req.user.handleUn)];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.operations.incr("l_c", 1)];
              client.operate(post_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "Liked post" });
                  if (meta.bins.likes.length === 0) {
                    const ops = [Aerospike.operations.incr("like", 1)];
                    const data = await client.operate(post_key, ops);
                    // return res.status(200).json({ msg: "Liked post" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      }
                    }
                  } else {
                    // return res.status(200).json({ msg: "Liked post" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      }
                    }
                  }
                }
              });
            }
          });
        }
      }
    } else {
      console.log("Like count 0");
      const ops = [Aerospike.lists.append("likes", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [
            Aerospike.operations.incr("l_c", 1),
            Aerospike.operations.incr("like", 1),
          ];
          client.operate(post_key, ops, async (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              // return res.status(200).json({ msg: "Liked post" });
              // ***
              if (post.bins.u_dun === req.user.handleUn) {
                return res.status(200).json({ msg: "Liked post" });
              } else {
                if (req.user.flwr_c > 2) {
                  console.log("Popular");
                  if (post.bins.pop.length <= 2) {
                    const ops = [
                      Aerospike.lists.append("pop", {
                        handleUn: req.user.handleUn,
                        pic: req.user.p_i || "",
                      }),
                    ];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "Liked post" });
                  } else {
                    return res.status(200).json({ msg: "Liked post" });
                  }
                } else {
                  console.log("Normal");
                  if (post.bins.ran.length <= 2) {
                    const ops = [
                      Aerospike.lists.append("ran", {
                        handleUn: req.user.handleUn,
                        pic: req.user.p_i || "",
                      }),
                    ];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "Liked post" });
                  } else {
                    return res.status(200).json({ msg: "Liked post" });
                  }
                }
              }
            }
          });
        }
      });
    }
  }
});

router.get("/view/full/post/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Not found" });
  } else {
    const key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );

    const data = await client.get(key);
    try {
      return res.status(200).json(data.bins);
    } catch (error) {
      return res.status(400).json({ msg: error.message });
    }
  }
});

// *** Create dislike emoji
router.put("/dislike/:id", async (req, res) => {
  const id = req.params.id;
  const client = await getAerospikeClient();
  if (!id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      id
    );

    const post = await client.get(post_key);
    if (post.bins.l_c > 0) {
      const meta = await client.get(post_meta_key);
      if (meta.bins.dislikes.includes(req.user.handleUn)) {
        const ops = [
          Aerospike.lists.removeByValue("dislikes", req.user.handleUn),
        ];
        client.operate(post_meta_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            const ops = [
              Aerospike.operations.incr("l_c", -1),
              Aerospike.operations.incr("dislike", 1),
            ];
            client.operate(post_key, ops, async (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                // return res.status(200).json({ msg: "Dislikes added" });
                if (meta.bins.haha.length === 1) {
                  const ops = [Aerospike.operations.incr("haha", -1)];
                  const data = await client.operate(post_key, ops);
                  return res.status(200).json({ msg: "remove haha post" });
                } else {
                  return res.status(200).json({ msg: "remove haha post" });
                }
              }
            });
          }
        });
      } else {
        if (
          meta.bins.likes.includes(req.user.handleUn) ||
          meta.bins.haha.includes(req.user.handleUn) ||
          meta.bins.angry.includes(req.user.handleUn) ||
          meta.bins.dislikes.includes(req.user.handleUn)
        ) {
          const ops = [
            Aerospike.lists.removeByValue("likes", req.user.handleUn),
            Aerospike.lists.removeByValue("haha", req.user.handleUn),
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
            Aerospike.lists.removeByValue("heart", req.user.handleUn),
          ];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [
                Aerospike.lists.append("dislikes", req.user.handleUn),
              ];
              client.operate(post_meta_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "Dislike post" });
                  if (meta.bins.dislikes.length === 0) {
                    const ops = [Aerospike.operations.incr("dislike", 1)];
                    const data = await client.operate(post_key, ops);
                    // return res.status(200).json({ msg: "Dislikes added" });

                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Dislike post" });
                        } else {
                          return res.status(200).json({ msg: "Dislike post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Dislike post" });
                        } else {
                          return res.status(200).json({ msg: "Dislike post" });
                        }
                      }
                    }
                  } else {
                    // return res.status(200).json({ msg: "Dislikes added" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Dislike post" });
                        } else {
                          return res.status(200).json({ msg: "Dislike post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Dislike post" });
                        } else {
                          return res.status(200).json({ msg: "Dislike post" });
                        }
                      }
                    }
                  }
                }
              });
            }
          });
        } else {
          const ops = [Aerospike.lists.append("dislikes", req.user.handleUn)];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [
                Aerospike.operations.incr("l_c", 1),
                Aerospike.operations.incr("dislikes", 1),
              ];
              client.operate(post_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "Dislikes added" });
                  if (meta.bins.dislikes.length === 0) {
                    const ops = [Aerospike.operations.incr("dislike", 1)];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "Dislikes added" });
                  } else {
                    return res.status(200).json({ msg: "Dislikes added" });
                  }
                }
              });
            }
          });
        }
      }
    } else {
      const ops = [Aerospike.lists.append("dislikes", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [Aerospike.operations.incr("l_c", 1)];
          client.operate(post_key, ops, async (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              // return res.status(200).json({ msg: "Dislikes added" });
              if (meta.bins.dislikes.length === 0) {
                const ops = [Aerospike.operations.incr("dislike", 1)];
                const data = await client.operate(post_key, ops);
                // return res.status(200).json({ msg: "Dislikes added" });

                if (post.bins.u_dun === req.user.handleUn) {
                  return res.status(200).json({ msg: "Dislike post" });
                } else {
                  if (req.user.flwr_c > 2) {
                    console.log("Popular");
                    if (post.bins.pop.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("pop", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      return res.status(200).json({ msg: "Dislike post" });
                    }
                  } else {
                    console.log("Normal");
                    if (post.bins.ran.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("ran", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      return res.status(200).json({ msg: "Dislike post" });
                    }
                  }
                }
              } else {
                // return res.status(200).json({ msg: "Dislikes added" });
                if (post.bins.u_dun === req.user.handleUn) {
                  return res.status(200).json({ msg: "Liked post" });
                } else {
                  if (req.user.flwr_c > 2) {
                    console.log("Popular");
                    if (post.bins.pop.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("pop", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      return res.status(200).json({ msg: "Dislike post" });
                    }
                  } else {
                    console.log("Normal");
                    if (post.bins.ran.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("ran", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Dislike post" });
                    } else {
                      return res.status(200).json({ msg: "Dislike post" });
                    }
                  }
                }
              }
            }
          });
        }
      });
    }
  }
});

// *** Create HAHA emoji
router.put("/haha/:id", async (req, res) => {
  const id = req.params.id;
  const client = await getAerospikeClient();
  console.log(req.params.id);
  if (!id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      id
    );

    const post = await client.get(post_key);
    if (post.bins.l_c > 0) {
      console.log("Like count greater than 0");
      const meta = await client.get(post_meta_key);
      if (meta.bins.haha.includes(req.user.handleUn)) {
        console.log("Already haha");
        const ops = [Aerospike.lists.removeByValue("haha", req.user.handleUn)];
        client.operate(post_meta_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            const ops = [Aerospike.operations.incr("l_c", -1)];
            client.operate(post_key, ops, async (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                // return res.status(200).json({ msg: "remove haha post" });
                if (meta.bins.haha.length === 1) {
                  const ops = [Aerospike.operations.incr("haha", -1)];
                  const data = await client.operate(post_key, ops);
                  return res.status(200).json({ msg: "remove haha post" });
                } else {
                  return res.status(200).json({ msg: "remove haha post" });
                }
              }
            });
          }
        });
      } else {
        console.log("Not like");
        if (
          meta.bins.likes.includes(req.user.handleUn) ||
          meta.bins.angry.includes(req.user.handleUn) ||
          meta.bins.dislikes.includes(req.user.handleUn)
        ) {
          console.log("Not like Other");
          const ops = [
            Aerospike.lists.removeByValue("likes", req.user.handleUn),
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
            Aerospike.lists.removeByValue("dislikes", req.user.handleUn),
          ];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.lists.append("haha", req.user.handleUn)];
              client.operate(post_meta_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  if (meta.bins.haha.length === 0) {
                    const ops = [Aerospike.operations.incr("haha", 1)];
                    const data = await client.operate(post_key, ops);
                    // return res.status(200).json({ msg: "haha post" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "HAHA post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "HAHA post" });
                        } else {
                          return res.status(200).json({ msg: "HAHA post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "HAHA post" });
                        } else {
                          return res.status(200).json({ msg: "HAHA post" });
                        }
                      }
                    }
                  } else {
                    // return res.status(200).json({ msg: "haha post" });

                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "HAHA post" });
                        } else {
                          return res.status(200).json({ msg: "haha post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "haha post" });
                        } else {
                          return res.status(200).json({ msg: "haha post" });
                        }
                      }
                    }
                  }
                }
              });
            }
          });
        } else {
          const ops = [Aerospike.lists.append("haha", req.user.handleUn)];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.operations.incr("l_c", 1)];
              client.operate(post_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  if (meta.bins.haha.length === 0) {
                    const ops = [Aerospike.operations.incr("haha", 1)];
                    const data = await client.operate(post_key, ops);
                    // return res.status(200).json({ msg: "haha post" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      }
                    }
                  } else {
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Liked post" });
                        } else {
                          return res.status(200).json({ msg: "Liked post" });
                        }
                      }
                    }
                    return res.status(200).json({ msg: "haha post" });
                  }
                }
              });
            }
          });
        }
      }
    } else {
      console.log("Like count 0");
      const ops = [Aerospike.lists.append("haha", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [
            Aerospike.operations.incr("l_c", 1),
            Aerospike.operations.incr("haha", 1),
          ];
          client.operate(post_key, ops, async (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              // return res.status(200).json({ msg: "HAHA post" });
              if (post.bins.u_dun === req.user.handleUn) {
                return res.status(200).json({ msg: "Liked post" });
              } else {
                if (req.user.flwr_c > 2) {
                  console.log("Popular");
                  if (post.bins.pop.length <= 2) {
                    const ops = [
                      Aerospike.lists.append("pop", {
                        handleUn: req.user.handleUn,
                        pic: req.user.p_i || "",
                      }),
                    ];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "Liked post" });
                  } else {
                    return res.status(200).json({ msg: "Liked post" });
                  }
                } else {
                  console.log("Normal");
                  if (post.bins.ran.length <= 2) {
                    const ops = [
                      Aerospike.lists.append("ran", {
                        handleUn: req.user.handleUn,
                        pic: req.user.p_i || "",
                      }),
                    ];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "Liked post" });
                  } else {
                    return res.status(200).json({ msg: "Liked post" });
                  }
                }
              }
            }
          });
        }
      });
    }
  }
});

// *** Create angry emoji
router.put("/angry/:id", async (req, res) => {
  const id = req.params.id;
  const client = await getAerospikeClient();
  if (!id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      id
    );

    const post = await client.get(post_key);
    if (post.bins.l_c > 0) {
      const meta = await client.get(post_meta_key);
      if (meta.bins.angry.includes(req.user.handleUn)) {
        const ops = [Aerospike.lists.removeByValue("angry", req.user.handleUn)];
        client.operate(post_meta_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            const ops = [Aerospike.operations.incr("l_c", -1)];
            client.operate(post_key, ops, async (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                // return res.status(200).json({ msg: "angry added" });
                if (meta.bins.angry.length === 1) {
                  const ops = [Aerospike.operations.incr("angry", -1)];
                  const data = await client.operate(post_key, ops);
                  return res.status(200).json({ msg: "angry added" });
                } else {
                  return res.status(200).json({ msg: "angry added" });
                }
              }
            });
          }
        });
      } else {
        if (
          meta.bins.likes.includes(req.user.handleUn) ||
          meta.bins.haha.includes(req.user.handleUn) ||
          meta.bins.angry.includes(req.user.handleUn) ||
          meta.bins.dislikes.includes(req.user.handleUn)
        ) {
          const ops = [
            Aerospike.lists.removeByValue("likes", req.user.handleUn),
            Aerospike.lists.removeByValue("haha", req.user.handleUn),
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
            Aerospike.lists.removeByValue("heart", req.user.handleUn),
          ];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.lists.append("angry", req.user.handleUn)];
              client.operate(post_meta_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "Angry post" });
                  if (meta.bins.angry.length === 0) {
                    const ops = [Aerospike.operations.incr("angry", 1)];
                    const data = await client.operate(post_key, ops);
                    return res.status(200).json({ msg: "angry added" });
                  } else {
                    return res.status(200).json({ msg: "angry added" });
                  }
                }
              });
            }
          });
        } else {
          const ops = [Aerospike.lists.append("angry", req.user.handleUn)];
          client.operate(post_meta_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              const ops = [Aerospike.operations.incr("l_c", 1)];
              client.operate(post_key, ops, async (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  // return res.status(200).json({ msg: "Angry  added" });
                  if (meta.bins.angry.length === 0) {
                    const ops = [Aerospike.operations.incr("angry", 1)];
                    const data = await client.operate(post_key, ops);
                    // return res.status(200).json({ msg: "angry added" });
                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Angry post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Angry post" });
                        } else {
                          return res.status(200).json({ msg: "Angry post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Angry post" });
                        } else {
                          return res.status(200).json({ msg: "Angry post" });
                        }
                      }
                    }
                  } else {
                    // return res.status(200).json({ msg: "angry added" });

                    if (post.bins.u_dun === req.user.handleUn) {
                      return res.status(200).json({ msg: "Liked post" });
                    } else {
                      if (req.user.flwr_c > 2) {
                        console.log("Popular");
                        if (post.bins.pop.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("pop", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Angry post" });
                        } else {
                          return res.status(200).json({ msg: "Angry post" });
                        }
                      } else {
                        console.log("Normal");
                        if (post.bins.ran.length <= 2) {
                          const ops = [
                            Aerospike.lists.append("ran", {
                              handleUn: req.user.handleUn,
                              pic: req.user.p_i || "",
                            }),
                          ];
                          const data = await client.operate(post_key, ops);
                          return res.status(200).json({ msg: "Angry post" });
                        } else {
                          return res.status(200).json({ msg: "Angry post" });
                        }
                      }
                    }
                  }
                }
              });
            }
          });
        }
      }
    } else {
      const ops = [Aerospike.lists.append("angry", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [
            Aerospike.operations.incr("l_c", 1),
            Aerospike.operations.incr("angry", 1),
          ];
          client.operate(post_key, ops, async (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              // return res.status(200).json({ msg: "angry added" });
              if (meta.bins.angry.length === 0) {
                const ops = [Aerospike.operations.incr("angry", 1)];
                const data = await client.operate(post_key, ops);
                // return res.status(200).json({ msg: "angry added" });

                if (post.bins.u_dun === req.user.handleUn) {
                  return res.status(200).json({ msg: "Angry post" });
                } else {
                  if (req.user.flwr_c > 2) {
                    console.log("Popular");
                    if (post.bins.pop.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("pop", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Angry post" });
                    } else {
                      return res.status(200).json({ msg: "Angry post" });
                    }
                  } else {
                    console.log("Normal");
                    if (post.bins.ran.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("ran", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Angry post" });
                    } else {
                      return res.status(200).json({ msg: "Angry post" });
                    }
                  }
                }
              } else {
                // return res.status(200).json({ msg: "angry added" });
                if (post.bins.u_dun === req.user.handleUn) {
                  return res.status(200).json({ msg: "Angry post" });
                } else {
                  if (req.user.flwr_c > 2) {
                    console.log("Popular");
                    if (post.bins.pop.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("pop", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Angry post" });
                    } else {
                      return res.status(200).json({ msg: "Angry post" });
                    }
                  } else {
                    console.log("Normal");
                    if (post.bins.ran.length <= 2) {
                      const ops = [
                        Aerospike.lists.append("ran", {
                          handleUn: req.user.handleUn,
                          pic: req.user.p_i || "",
                        }),
                      ];
                      const data = await client.operate(post_key, ops);
                      return res.status(200).json({ msg: "Angry post" });
                    } else {
                      return res.status(200).json({ msg: "Angry post" });
                    }
                  }
                }
              }
            }
          });
        }
      });
    }
  }
});

router.get("/:id/liked_user", async (req, res) => {
  const client = await getAerospikeClient();
  const arr = [];

  const group_posts_analytics_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POSTS_ANALYTICS,
    req.params.id.toString()
  );
  var data = await client.get(group_posts_analytics_key);
  console.log(data.bins.likes);
  for (i = 0; i < data.bins.likes_arr.length; i++) {
    let user_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_USERS,
      data.bins.likes_arr[i].toString()
    );
    const user_data = await client.get(user_key);
    arr.push(user_data.bins);
  }
  return res.status(200).json({ post_likes: arr });
});

router.get("/:id", async (req, res) => {
  const client = await getAerospikeClient();
  var query = client.query(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POSTS
  );
  if (!req.params.id) {
    return res.status(401).json({ msg: "Group id is not present" });
  } else {
    // console.log(req.params.id)
    var stream = query.foreach();
    var arr = [];
    stream.on("data", async (data) => {
      // console.log(data.bins);
      if (data.bins.group_id === req.params.id.toString()) {
        const metaDataKey = new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.SET_GROUP_POSTS_ANALYTICS,
          data.bins.p_id
        );
        // const metaData = await client.get(metaDataKey);
        // const postData = {...data.bins, ...metaData.bins}
        // arr.push({...data.bins, ...metaData.bins});
        // console.log(data.bins.p_id);
        arr.push(data.bins);
      }
    });

    stream.on("end", function (posts) {
      if (req.query.sortedBy === "old") {
        var temp = arr.sort((a, b) => a.c_t - b.c_t);
        var page = req.query.page || 1;
        var limit = req.query.limit || 10;
        var results = [];
        var start = (page - 1) * limit;
        var end = page * limit;
        if (page <= limit) {
          temp = temp.slice(start, end);
        }
        return res.status(200).json({ posts: temp });
      } else if (req.query.sortedBy === "popular") {
        var temp = arr.sort((a, b) => b.l_c - a.l_c);
        var page = req.query.page || 1;
        var limit = req.query.limit || 10;
        var results = [];
        var start = (page - 1) * limit;
        var end = page * limit;
        if (page <= limit) {
          temp = temp.slice(start, end);
        }
        return res.status(200).json({ posts: temp });
      } else {
        var temp = arr.sort((a, b) => b.c_t - a.c_t);
        var page = req.query.page || 1;
        var limit = req.query.limit || 10;
        var results = [];
        var start = (page - 1) * limit;
        var end = page * limit;
        if (page <= limit) {
          temp = temp.slice(start, end);
        }
        return res.status(200).json({ posts: temp });
      }
    });
  }
});

router.get("/like/users/:id", async (req, res) => {
  const client = await getAerospikeClient();
  const batchType = Aerospike.batchType;
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META
    );
    const tempBin = "ExpVar"; // this bin is to hold expression read operation output
    // query.select("likes", "heart", "haha", "party", "dislike"); //select single bin
    // query.where(Aerospike.filter.equal("p_id", req.params.id));
    const stream = query.foreach();
    var arr = [];
    var temp = [];
    var users = [];

    console.log(req.query.type);

    stream.on("data", function (record) {
      if (req.query.type === "all") {
        arr = [
          ...record.bins.likes,
          ...record.bins.haha,
          ...record.bins.angry,
          ...record.bins.dislikes,
        ];
      }
      // Only likes
      else if (req.query.type === "likes") {
        arr = record.bins.likes;
        console.log("Likes ", arr);
      }
      // Only heart
      if (req.query.type === "heart") {
        arr = record.bins.heart;
        console.log("Heart ", arr);
      }
      // Only party
      else if (req.query.type === "angry") {
        arr = record.bins.angry;
      }
      // only haha
      else if (req.query.type === "haha") {
        arr = record.bins.haha;
      }
      // only dislikes
      else if (req.query.type === "dislikes") {
        arr = record.bins.dislikes;
      }

      for (let i = 0; i < arr.length; i++) {
        temp.push({
          key: new Aerospike.Key(
            process.env.CLUSTER_NAME,
            process.env.SET_USERS,
            arr[i]
          ),
          type: batchType.BATCH_READ,
          readAllBins: false,
          bins: ["handleUn", "fn", "ln", "p_i"],
        });
      }
    });

    stream.on("end", async function (record) {
      client.batchRead(temp, async (err, results) => {
        users = results;
        var page = req.query.page || 1;
        var limit = 5;
        var start = (page - 1) * limit;
        var end = page * limit;

        users = users.splice(start, end);
        return res.status(200).json(users);
      });
    });
  }
});

// *** Create block post feed
router.get("/block/feed", async (req, res) => {
  // group_posts
  const client = await getAerospikeClient();
  let query = client.query(process.env.CLUSTER_NAME, process.env.SET_GROUP);
  const tempBin1 = "ExpVar";
  const stream = query.foreach();
  var arr = [];
  var temp = [];
  var result = [];
  var posts = [];

  stream.on("data", function (record) {
    if (record.bins.g_mem.includes(req.user.handleUn)) {
      arr.push({
        key: new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.SET_GROUP_META,
          record.bins.g_id
        ),
        readAllBins: true,
      });
    }
  });

  stream.on("end", function (record) {
    client.batchRead(arr, async (err, results) => {
      results.map((data) => {
        var posts = data.record.bins.posts;
        temp = [...temp, ...posts];
        for (let i = 0; i < temp.length; i++) {
          result.push({
            key: new Aerospike.Key(
              process.env.CLUSTER_NAME,
              process.env.SET_GROUP_POSTS,
              temp[i]
            ),
            readAllBins: true,
          });
        }
        client.batchRead(result, async (err, results) => {
          results.map((data) => {
            if (data.bins) {
              posts.push(data.bins);
            }
          });
        });
      });
      return res.status(200).json(posts);
    });
  });

  // stream.on("data", function (record) {
  //   arr.push(record.bins);
  // });

  // stream.on("end", function (record) {
  //   console.log(arr);
  //   // if (req.query.key === "Date") {
  //   //   arr = arr.sort((a, b) => b.p_id - a.p_id);
  //   // } else if (req.query.key === "Event") {
  //   //   arr = arr.filter((data) => data.isEvent == true);
  //   //   arr = arr.sort((a, b) => b.p_id - a.p_id);
  //   // } else if (req.query.key === "Recomended") {
  //   //   arr = arr.filter((data) => data.isEvent == false);
  //   //   arr = arr.sort((a, b) => b.likes - a.likes);
  //   // }
  //   // var page = req.query.page || 1;
  //   // var limit = req.query.limit || 5;
  //   // var start = (page - 1) * limit;
  //   // var end = page * limit;
  //   // var count = 0;

  //   // arr = arr.slice(start, end);
  //   // return res.status(200).json(arr);
  // });
});

router.get("/single/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(401).json({ msg: "Group id is not present" });
  } else {
    // console.log("Id")
    // var query = client.query(process.env.CLUSTER_NAME, process.env.SET_GROUP_POSTS);
    // var stream = query.foreach(data => console.log(data));
    // // var postData;
    // stream.on('data', function (data) {
    //   // console.log(data.bins);
    //   postData = data.bins;
    // });

    // stream.on('end', function (posts) {
    //   // console.log(arr);
    //   return res.status(200).json({ posts: postData });
    // });
    var post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id.toString()
    );
    var post_key_analytics = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "group_posts_meta",
      req.params.id.toString()
    );

    const postAnalyticsData = await client.get(post_key_analytics);
    const data = postAnalyticsData.bins;

    try {
      return res.status(200).json(data);
    } catch (err) {
      return res.status(501).json({ msg: err.message });
    }
  }
});

router.get("/full-post/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(401).json({ msg: "Group id is not present" });
  } else {
    // console.log("Id")
    // var query = client.query(process.env.CLUSTER_NAME, process.env.SET_GROUP_POSTS);
    // var stream = query.foreach(data => console.log(data));
    // // var postData;
    // stream.on('data', function (data) {
    //   // console.log(data.bins);
    //   postData = data.bins;
    // });

    // stream.on('end', function (posts) {
    //   // console.log(arr);
    //   return res.status(200).json({ posts: postData });
    // });
    var post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id.toString()
    );

    const post = await client.get(post_key);
    const data = post.bins;

    try {
      return res.status(200).json(data);
    } catch (err) {
      return res.status(501).json({ msg: err.message });
    }
  }
});

// Create Post emoji like
router.put("/like-emoji/:id", async (req, res) => {
  if (!req.params.id) {
    return res.status(401).json({ msg: "Invalid request params" });
  } else {
    var post = await GroupPost.findById(req.params.id);
    var user = await User.findById(req.user._id);
    if (!post) {
      return res.status(401).json({ msg: "No post found" });
    } else {
      for (const [key, value] of Object.entries(post.reactions)) {
        var str = `reactions.${key}`;
        post = await GroupPost.findByIdAndUpdate(
          req.params.id,
          { $pull: { [str]: req.user._id } },
          { new: true }
        );
      }

      var queryStr = `reactions.${req.query.type}`;
      var groupQueryStr = `group_reactions.${req.query.type}`;

      post = await GroupPost.findByIdAndUpdate(
        req.params.id,
        { $addToSet: { [queryStr]: req.user._id } },
        { new: true }
      );

      return res.status(200).json({ post, user });
    }
  }
});

// Create Post spam
router.put("/spam/:id", async (req, res) => {
  const client = await getAerospikeClient();

  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    var post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    var post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      req.params.id
    );

    const meta_data = await client.get(post_meta_key);
    if (meta_data.bins.spam.includes(req.user.handleUn)) {
      const ops = [Aerospike.lists.removeByValue("spam", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [Aerospike.operations.incr("spam", -1)];
          client.operate(post_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(post_feed_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  return res.status(200).json(result);
                }
              });
            }
          });
        }
      });
    } else {
      const ops = [Aerospike.lists.append("spam", req.user.handleUn)];
      client.operate(post_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops = [Aerospike.operations.incr("spam", 1)];
          client.operate(post_key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(post_feed_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  return res.status(200).json(result);
                }
              });
            }
          });
        }
      });
    }
  }
});

router.put("/bookmark/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Inva;lid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST
    );
    const tempBin = "ExpVar"; // this bin is to hold expression read operation output
    query.select(["book"]); //select single bin
    query.where(Aerospike.filter.equal("p_id", req.params.id));
    const stream = query.foreach();
    stream.on("data", async function (record) {
      console.log(record);
      var bookmarkArr = record.bins.book;
      if (bookmarkArr.includes(req.user.handleUn)) {
        // console.log("Bookmarked")
        const ops = [Aerospike.lists.removeByValue("book", req.user.handleUn)];
        await client.operate(post_key, ops);
        try {
          await client.operate(post_feed_key, ops);
        } catch (error) {
          return res.status(400).json({ msg: error.message });
        }
      } else {
        // console.log("Not Bookmarked")
        const ops = [Aerospike.lists.append("book", req.user.handleUn)];
        await client.operate(post_key, ops);
        try {
          await client.operate(post_feed_key, ops);
        } catch (error) {
          return res.status(400).json({ msg: error.message });
        }
      }
    });
    stream.on("end", async function (posts) {
      var postData = await client.get(post_key);
      res.status(200).json(postData.bins);
    });
  }
});

// Create Repost Post route
router.post("/repost/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ mg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const data = await client.get(post_key);
    try {
      // console.log(data.bins);
      var post_id = now.micro();
      const re_post_key = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_MAIN_GROUP_POST,
        post_id
      );
      const post_meta_key = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_GROUP_POST_META,
        post_id.toString()
      );
      const post_comment = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_GROUP_POST_COMMENT,
        post_id.toString()
      );
      const original = data.bins;
      const post_bins = {
        p_id: post_id.toString(),
        likes: 0,
        book: [],
        pinned: false,
        content: original.content,
        u_id: original.u_id.toString(),
        u_fn: original.u_fn,
        u_ln: original.u_ln,
        u_dun: original.u_dun,
        u_img: original.u_img,
        hide: [],
        spam: 0,
        c_t: new Date().getTime().toString(),
        u_t: new Date().getTime().toString(),
        comments: [],
        url: "",
        group_id: original.group_id.toString(),
        shares: 0,
        tran_cnt: 0,
        isReposted: true,
        deleted: false,
        is_share: true,
        share_d: {
          u_id: req.user.u_id.toString(),
          u_fn: req.user.fn,
          u_ln: req.user.ln,
          u_dun: req.user.handleUn,
          u_img: req.user.p_i,
          r_content: req.body.repostContent || "",
        },
      };
      const post_meta_bins = {
        p_id: post_id.toString(),
        likes: [],
        heart: [],
        haha: [],
        party: [],
        dislikes: [],
        spam: [],
        share: [],
      };
      const post_comment_bins = {
        pid: post_id,
      };
      await client.put(post_meta_key, post_meta_bins);
      await client.put(re_post_key, post_bins);
      await client.put(post_comment, post_comment_bins);
      const ops = [Aerospike.operations.incr("shares", 1)];
      await client.operate(post_key, ops);

      const post_data = await client.get(re_post_key);
      return res.status(200).json({ msg: "Post shared", post: post_data.bins });
    } catch (err) {
      return res.status(400).json({ msg: err.message });
    }
  }
});

// Repost group post with quote

// Create Post Edit route
router.put("/edit/:id", multer.single("image"), async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    if (!req.file) {
      const post_meta_key = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_GROUP_POST_META,
        req.params.id
      );
      const post_key = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_MAIN_GROUP_POST,
        req.params.id
      );
      const post_feed_key = new Aerospike.Key(
        process.env.CLUSTER_NAME,
        process.env.SET_GROUP_POSTS,
        req.params.id
      );

      let query = client.query(
        process.env.CLUSTER_NAME,
        process.env.SET_GROUP_POSTS
      );
      const tempBin = "ExpVar"; // this bin is to hold expression read operation output
      query.select(["content", "gif"]); //select single bin
      query.where(Aerospike.filter.equal("p_id", req.params.id));

      const stream = query.foreach();
      stream.on("data", async function (record) {
        console.log(record);
        const ops = [
          Aerospike.operations.write("content", req.body.content),
          Aerospike.operations.write("gif", req.body.gif),
        ];
        await client.operate(post_key, ops);
        try {
          await client.operate(post_feed_key, ops);
        } catch (error) {
          return res.status(400).json({ msg: error.message });
        }
      });

      stream.on("end", async function (posts) {
        var postData = await client.get(post_key);
        // console.log(postData)
        res.status(200).json(postData.bins);
      });
    } else {
      const newImageName = uuidv1() + "-" + req.file.originalname;
      const blob = bucket.file(newImageName);
      const blobStream = blob.createWriteStream();
      blobStream.on("finish", async () => {
        var publicURL = `https://storage.googleapis.com/${process.env.GCS_BUCKET}/${blob.name}`;

        const post_key = new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.SET_GROUP_POSTS,
          req.params.id
        );

        let query = client.query(
          process.env.CLUSTER_NAME,
          process.env.SET_GROUP_POSTS
        );
        const tempBin = "ExpVar"; // this bin is to hold expression read operation output
        query.select(["content", "gif", "image"]); //select single bin
        query.where(Aerospike.filter.equal("p_id", req.params.id));

        const stream = query.foreach();
        stream.on("data", async function (record) {
          console.log(record);
          const ops = [
            Aerospike.operations.write("content", req.body.content),
            Aerospike.operations.write("gif", req.body.gif),
            Aerospike.operations.write("image", publicURL),
          ];
          await client.operate(post_key, ops);
        });

        stream.on("end", async function (posts) {
          var postData = await client.get(post_key);
          console.log(postData);
          res.status(200).json(postData.bins);
        });
      });
      blobStream.on("error", (err) => {
        console.log(err);
        return res.status(400).json({ msg: err.message });
      });
      blobStream.end(req.file.buffer);
    }
  }
});

// Create Pinned Post route
router.put("/pinned/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST
    );
    const tempBin = "ExpVar"; // this bin is to hold expression read operation output
    query.select(["pinned"]); //select single bin
    query.where(Aerospike.filter.equal("p_id", req.params.id));

    // const queryPolicy = new Aerospike.QueryPolicy({});
    const stream = query.foreach();
    stream.on("data", async function (record) {
      if (record.bins.pinned) {
        const ops = [Aerospike.operations.write("pinned", false)];
        await client.operate(post_key, ops);
        try {
          await client.operate(post_feed_key, ops);
        } catch (error) {
          return res.status(400).json({ msg: err.message });
        }
      } else {
        const ops = [Aerospike.operations.write("pinned", true)];
        await client.operate(post_key, ops);
        try {
          await client.operate(post_feed_key, ops);
        } catch (error) {
          return res.status(400).json({ msg: err.message });
        }
      }
    });
    stream.on("end", async function (posts) {
      var postData = await client.get(post_key);
      console.log(postData.bins);
      res.status(200).json(postData.bins);
    });
  }
});

// Create Delete Post route
router.delete("/delete/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );

    client
      .exists(post_key)
      .then((data) => {
        const ops = [Aerospike.operations.write("deleted", true)];
        client.operate(post_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            client.operate(post_feed_key, ops, (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                return res
                  .status(200)
                  .json({ msg: "Post deleted", result: result.bins });
              }
            });
          }
        });
      })
      .catch((err) => {
        return res.status(400).json({ msg: err.message });
      });
  }
});

// POST HIDE & UNHIDE ROUTE
router.put("/hide/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Inva;lid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );

    const ops = [Aerospike.lists.append("hide", req.user.handleUn)];
    const data = await client.operate(post_key, ops);
    try {
      const data = await client.operate(post_feed_key, ops);
      try {
        return res.status(200).json(data);
      } catch (error) {
        return res.status(400).json({ msg: error.message });
      }
    } catch (error) {
      return res.status(400).json({ msg: error.message });
    }
  }
});

// ******* CREATE GROUP POST API REDESIGN ******* //
router.post("/create/post/:id", multer.single("image"), async (req, res) => {
  console.log("New API Call ", req.body);
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request params" });
  } else {
    // **** START **** //
    const batchType = Aerospike.batchType;
    const post_id = now.micro();
    const client = await getAerospikeClient();
    const oldString = req.body.content
      .trim()
      .replace(/(\r\n|\n|\r|(  ))/gm, " ")
      .split(" ");
    const newString = removeStopwords(oldString, eng);
    const post_content = req.body.content ? req.body.content : "";
    const post_gif = req.body.gif ? req.body.gif : "";

    // *** Create post key (FEED)
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      post_id.toString()
    );
    // *** Create post key (MAIN)
    const main_post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      post_id.toString()
    );
    // *** Creating post meta key
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      post_id
    );
    const post_counter_ops = [
      Aerospike.operations.incr("cc", 1),
      Aerospike.operations.read("cc"),
    ];
    // const counterData = await client.operate(post_testmp_key, post_counter_ops);
    // *** Poct comment table
    const post_comment = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT,
      post_id.toString()
    );

    // *** Group meta
    const group_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_META,
      req.params.id
    );

    let batchPolicy1 = new Aerospike.BatchPolicy({});

    // **** Here we generate keys for SEARCHING post
    var dstring = newString;
    // console.log(newString)
    var keys = [];
    for (i = 0; i < dstring.length; i++) {
      var sstr = dstring[i];
      keys.push(
        new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.POST_SEARCH,
          sstr
        )
      );
    }
    batchArrKeys = [
      post_key,
      post_meta_key,
      keys,
      post_comment,
      main_post_key,
      group_meta_key,
    ];
    if (!req.file) {
      var batchRecords = [];
      for (let i = 0; i < batchArrKeys.length; i++) {
        // *** Posts
        if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("p_id", post_id), // user post list
              Aerospike.operations.write("likes", 0), // group post likes
              Aerospike.operations.write("book", []), // group post bookmark
              Aerospike.operations.write("pinned", false), // group post pinned
              Aerospike.operations.write("content", req.body.content), // post content
              Aerospike.operations.write("gif", req.body.gif), // post gif
              Aerospike.operations.write("likes", 0),
              Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
              Aerospike.operations.write("u_fn", req.user.fn), //first name
              Aerospike.operations.write("u_ln", req.user.ln), //lastname
              Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
              Aerospike.operations.write("u_img", req.user.p_i),
              Aerospike.operations.write("hide", []), //group post hide
              Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
              Aerospike.operations.write("spam", 0), //post spam count
              Aerospike.operations.write(
                "c_t",
                new Date().getTime().toString()
              ),
              Aerospike.operations.write(
                "u_t",
                new Date().getTime().toString()
              ),
              Aerospike.operations.write("comments", []), //post comment list
              Aerospike.operations.write("url", ""),
              Aerospike.operations.write("group_id", req.params.id.toString()),
              Aerospike.operations.write("shares", 0), //post share count
              Aerospike.operations.write("tran_cnt", 0),
              Aerospike.operations.write("isEvent", false),
              Aerospike.operations.write("isReposted", false),
              Aerospike.operations.write("deleted", false),
              Aerospike.operations.write("is_share", false),
              Aerospike.operations.write("c_c", 0),
              Aerospike.operations.write("l_c", 0),
              Aerospike.operations.write("statusText", req.body.statusText),
              Aerospike.operations.write("userLocation", req.body.userLocation),
            ],
          });
        } else if (batchArrKeys[i].set === process.env.SET_MAIN_GROUP_POST) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("p_id", post_id), // user post list
              Aerospike.operations.write("likes", 0), // group post likes
              Aerospike.operations.write("book", []), // group post bookmark
              Aerospike.operations.write("pinned", false), // group post pinned
              Aerospike.operations.write("content", req.body.content), // post content
              Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
              Aerospike.operations.write("gif", req.body.gif), // post gif
              Aerospike.operations.write("likes", 0),
              Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
              Aerospike.operations.write("u_fn", req.user.fn), //first name
              Aerospike.operations.write("u_ln", req.user.ln), //lastname
              Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
              Aerospike.operations.write("u_img", req.user.p_i),
              Aerospike.operations.write("hide", []), //group post hide
              Aerospike.operations.write("spam", 0), //post spam count
              Aerospike.operations.write(
                "c_t",
                new Date().getTime().toString()
              ),
              Aerospike.operations.write(
                "u_t",
                new Date().getTime().toString()
              ),
              Aerospike.operations.write("comments", []), //post comment list
              Aerospike.operations.write("url", ""),
              Aerospike.operations.write("group_id", req.params.id.toString()),
              Aerospike.operations.write("shares", 0), //post share count
              Aerospike.operations.write("tran_cnt", 0),
              Aerospike.operations.write("isReposted", false),
              Aerospike.operations.write("deleted", false),
              Aerospike.operations.write("is_share", false),
              Aerospike.operations.write("c_c", 0),
              Aerospike.operations.write("l_c", 0),
            ],
          });
        }
        // *** Group post meta
        else if (batchArrKeys[i].set === process.env.SET_GROUP_POST_META) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("p_id", post_id),
              Aerospike.operations.write("heart", []),
              Aerospike.operations.write("haha", []),
              Aerospike.operations.write("angry", []),
              Aerospike.operations.write("dislikes", []),
              Aerospike.operations.write("spam", []),
              Aerospike.operations.write("share", []),
            ],
          });
        }

        // *** Group post comment
        else if (batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("pid", post_id), // user post list
            ],
          });
        }
        // *** Save posts id in group meta data
        else if (batchArrKeys[i].set === process.env.SET_GROUP_META) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.lists.append("posts", post_id), // user post list
            ],
          });
        }

        // *** Group post search
        else if (Array.isArray(batchArrKeys[i])) {
          if (batchArrKeys[i].length > 0) {
            if (batchArrKeys[i][0].set === process.env.SET_POSTS_SEARCH) {
              let batchPolicy = new Aerospike.BatchPolicy({});
              let exists = await client.batchExists(
                batchArrKeys[i],
                batchPolicy
              );
              exists.forEach(async (result) => {
                var pk_word = result.record.key.key; //primary key
                var shortKey = pk_word.slice(0, 2).toLowerCase();
                // var timestmp = new Date().getTime().toString()
                var pid = `${post_id}`; //post id to append
                if (req.query.flwr_count > 0) {
                  console.log("Celb");
                  if (result.status !== 0) {
                    batchRecords.push({
                      type: batchType.BATCH_WRITE,
                      key: result.record.key,
                      ops: [
                        Aerospike.operations.write("p_k", pk_word),
                        Aerospike.operations.write("f_t", shortKey),
                        Aerospike.operations.write("celb_c", 1),
                        Aerospike.lists.append("celb_p_l", pid), // user post list
                      ],
                    });
                  } else {
                    batchRecords.push({
                      type: batchType.BATCH_WRITE,
                      key: result.record.key,
                      ops: [
                        //if exists, append
                        Aerospike.lists.append("celb_p_l", pid),
                        Aerospike.operations.incr("celb_c", 1),
                      ],
                    });
                  }
                } else {
                  console.log("Normal");
                  if (result.status !== 0) {
                    batchRecords.push({
                      type: batchType.BATCH_WRITE,
                      key: result.record.key,
                      ops: [
                        Aerospike.operations.write("p_k", pk_word),
                        Aerospike.operations.write("f_t", shortKey),
                        Aerospike.operations.write("u_c", 1),
                        Aerospike.lists.append("u_p_l", pid), // user post list
                      ],
                    });
                  } else {
                    batchRecords.push({
                      type: batchType.BATCH_WRITE,
                      key: result.record.key,
                      ops: [
                        //if exists, append
                        Aerospike.lists.append("u_p_l", pid),
                        Aerospike.operations.incr("u_c", 1),
                      ],
                    });
                  }
                }
              });
            }
          }
        }
      }
      await client.batchWrite(batchRecords, batchPolicy1);
      try {
        var getPostData = await client.get(post_key);
        return res.status(201).json(getPostData.bins);
      } catch (err) {
        return res.status(400).json({ msg: err.message });
      }
    } else {
      if (req.file.mimetype.includes("image")) {
        const newImageName = post_id + "-" + req.file.originalname;
        const blob = bucket.file(newImageName);
        const blobStream = blob.createWriteStream();

        blobStream.on("error", (err) => {
          console.log(err);
          return res.status(400).json({ msg: err.message });
        });

        blobStream.on("finish", async () => {
          var publicURL = `https://storage.googleapis.com/${process.env.GCS_BUCKET}/${blob.name}`;
          console.log(publicURL);
          var batchRecords = [];
          for (let i = 0; i < batchArrKeys.length; i++) {
            // *** Posts
            if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("p_id", post_id), // user post list
                  Aerospike.operations.write("likes", 0), // group post likes
                  Aerospike.operations.write("book", []), // group post bookmark
                  Aerospike.operations.write("pinned", false), // group post pinned
                  Aerospike.operations.write("content", req.body.content || ""), // post content
                  Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                  Aerospike.operations.write("image", publicURL), // post gif
                  Aerospike.operations.write("likes", 0),
                  Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
                  Aerospike.operations.write("u_fn", req.user.fn), //first name
                  Aerospike.operations.write("u_ln", req.user.ln), //lastname
                  Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
                  Aerospike.operations.write("u_img", req.user.p_i),
                  Aerospike.operations.write("hide", []), //group post hide
                  Aerospike.operations.write("spam", 0), //post spam count
                  Aerospike.operations.write(
                    "c_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write(
                    "u_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write("comments", []), //post comment list
                  Aerospike.operations.write("url", ""),
                  Aerospike.operations.write(
                    "group_id",
                    req.params.id.toString()
                  ),
                  Aerospike.operations.write("shares", 0), //post share count
                  Aerospike.operations.write("tran_cnt", 0),
                  Aerospike.operations.write("isReposted", false),
                  Aerospike.operations.write("deleted", false),
                  Aerospike.operations.write("is_share", false),
                  Aerospike.operations.write("c_c", 0),
                  Aerospike.operations.write("l_c", 0),
                ],
              });
            } else if (
              batchArrKeys[i].set === process.env.SET_MAIN_GROUP_POST
            ) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("p_id", post_id), // user post list
                  Aerospike.operations.write("likes", 0), // group post likes
                  Aerospike.operations.write("book", []), // group post bookmark
                  Aerospike.operations.write("pinned", false), // group post pinned
                  Aerospike.operations.write("content", req.body.content), // post content
                  Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                  Aerospike.operations.write("image", publicURL), // post gif
                  Aerospike.operations.write("likes", 0),
                  Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
                  Aerospike.operations.write("u_fn", req.user.fn), //first name
                  Aerospike.operations.write("u_ln", req.user.ln), //lastname
                  Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
                  Aerospike.operations.write("u_img", req.user.p_i),
                  Aerospike.operations.write("hide", []), //group post hide
                  Aerospike.operations.write("spam", 0), //post spam count
                  Aerospike.operations.write(
                    "c_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write(
                    "u_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write("comments", []), //post comment list
                  Aerospike.operations.write("url", ""),
                  Aerospike.operations.write(
                    "group_id",
                    req.params.id.toString()
                  ),
                  Aerospike.operations.write("shares", 0), //post share count
                  Aerospike.operations.write("tran_cnt", 0),
                  Aerospike.operations.write("isReposted", false),
                  Aerospike.operations.write("deleted", false),
                  Aerospike.operations.write("is_share", false),
                  Aerospike.operations.write("c_c", 0),
                  Aerospike.operations.write("l_c", 0),
                ],
              });
            }
            // *** Group post meta
            else if (batchArrKeys[i].set === process.env.SET_GROUP_POST_META) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("p_id", post_id),
                  Aerospike.operations.write("heart", []),
                  Aerospike.operations.write("haha", []),
                  Aerospike.operations.write("angry", []),
                  Aerospike.operations.write("dislikes", []),
                  Aerospike.operations.write("spam", []),
                  Aerospike.operations.write("share", []),
                ],
              });
            }

            // *** Group post comment
            else if (
              batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT
            ) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("pid", post_id), // user post list
                ],
              });
            }

            // ***
            else if (batchArrKeys[i].set === process.env.SET_GROUP_META) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.lists.append("posts", post_id), // user post list
                ],
              });
            }

            // *** Group post search
            else if (Array.isArray(batchArrKeys[i])) {
              if (batchArrKeys[i].length > 0) {
                if (batchArrKeys[i][0].set === process.env.SET_POSTS_SEARCH) {
                  let batchPolicy = new Aerospike.BatchPolicy({});
                  let exists = await client.batchExists(
                    batchArrKeys[i],
                    batchPolicy
                  );
                  exists.forEach(async (result) => {
                    var pk_word = result.record.key.key; //primary key
                    var shortKey = pk_word.slice(0, 2).toLowerCase();
                    // var timestmp = new Date().getTime().toString()
                    var pid = `${post_id}`; //post id to append
                    if (req.query.flwr_count > 0) {
                      console.log("Celb");
                      if (result.status !== 0) {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            Aerospike.operations.write("p_k", pk_word),
                            Aerospike.operations.write("f_t", shortKey),
                            Aerospike.operations.write("celb_c", 1),
                            Aerospike.lists.append("celb_p_l", pid), // user post list
                          ],
                        });
                      } else {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            //if exists, append
                            Aerospike.lists.append("celb_p_l", pid),
                            Aerospike.operations.incr("celb_c", 1),
                          ],
                        });
                      }
                    } else {
                      console.log("Normal");
                      if (result.status !== 0) {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            Aerospike.operations.write("p_k", pk_word),
                            Aerospike.operations.write("f_t", shortKey),
                            Aerospike.operations.write("u_c", 1),
                            Aerospike.lists.append("u_p_l", pid), // user post list
                          ],
                        });
                      } else {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            //if exists, append
                            Aerospike.lists.append("u_p_l", pid),
                            Aerospike.operations.incr("u_c", 1),
                          ],
                        });
                      }
                    }
                  });
                }
              }
            }
          }
          await client.batchWrite(batchRecords, batchPolicy1);
          try {
            var getPostData = await client.get(post_key);
            return res.status(201).json(getPostData.bins);
          } catch (err) {
            return res.status(400).json({ msg: err.message });
          }
        });
        blobStream.end(req.file.buffer);
      } else {
        const newImageName = post_id + "-" + req.file.originalname;
        const blob = bucket.file(newImageName);
        const blobStream = blob.createWriteStream();

        blobStream.on("error", (err) => {
          console.log(err);
          return res.status(400).json({ msg: err.message });
        });

        blobStream.on("finish", async () => {
          var publicURL = `https://storage.googleapis.com/${process.env.GCS_BUCKET}/${blob.name}`;
          console.log(publicURL);
          var batchRecords = [];
          for (let i = 0; i < batchArrKeys.length; i++) {
            // *** Posts
            if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("p_id", post_id), // user post list
                  Aerospike.operations.write("likes", 0), // group post likes
                  Aerospike.operations.write("book", []), // group post bookmark
                  Aerospike.operations.write("pinned", false), // group post pinned
                  Aerospike.operations.write("content", req.body.content || ""), // post content
                  Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                  Aerospike.operations.write("video", publicURL), // post gif
                  Aerospike.operations.write("likes", 0),
                  Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
                  Aerospike.operations.write("u_fn", req.user.fn), //first name
                  Aerospike.operations.write("u_ln", req.user.ln), //lastname
                  Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
                  Aerospike.operations.write("u_img", req.user.p_i),
                  Aerospike.operations.write("hide", []), //group post hide
                  Aerospike.operations.write("spam", 0), //post spam count
                  Aerospike.operations.write(
                    "c_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write(
                    "u_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write("comments", []), //post comment list
                  Aerospike.operations.write("url", ""),
                  Aerospike.operations.write(
                    "group_id",
                    req.params.id.toString()
                  ),
                  Aerospike.operations.write("shares", 0), //post share count
                  Aerospike.operations.write("tran_cnt", 0),
                  Aerospike.operations.write("isReposted", false),
                  Aerospike.operations.write("deleted", false),
                  Aerospike.operations.write("is_share", false),
                  Aerospike.operations.write("c_c", 0),
                  Aerospike.operations.write("l_c", 0),
                  Aerospike.operations.write("statusText", req.body.statusText),
                  Aerospike.operations.write(
                    "userLocation",
                    req.body.userLocation
                  ),
                ],
              });
            } else if (
              batchArrKeys[i].set === process.env.SET_MAIN_GROUP_POST
            ) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("p_id", post_id), // user post list
                  Aerospike.operations.write("likes", 0), // group post likes
                  Aerospike.operations.write("book", []), // group post bookmark
                  Aerospike.operations.write("pinned", false), // group post pinned
                  Aerospike.operations.write("content", req.body.content), // post content
                  Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                  Aerospike.operations.write("video", publicURL), // post gif
                  Aerospike.operations.write("likes", 0),
                  Aerospike.operations.write("u_id", req.user.u_id.toString()), //post userID
                  Aerospike.operations.write("u_fn", req.user.fn), //first name
                  Aerospike.operations.write("u_ln", req.user.ln), //lastname
                  Aerospike.operations.write("u_dun", req.user.handleUn), //handleun
                  Aerospike.operations.write("u_img", req.user.p_i),
                  Aerospike.operations.write("hide", []), //group post hide
                  Aerospike.operations.write("spam", 0), //post spam count
                  Aerospike.operations.write(
                    "c_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write(
                    "u_t",
                    new Date().getTime().toString()
                  ),
                  Aerospike.operations.write("comments", []), //post comment list
                  Aerospike.operations.write("url", ""),
                  Aerospike.operations.write(
                    "group_id",
                    req.params.id.toString()
                  ),
                  Aerospike.operations.write("shares", 0), //post share count
                  Aerospike.operations.write("tran_cnt", 0),
                  Aerospike.operations.write("isReposted", false),
                  Aerospike.operations.write("deleted", false),
                  Aerospike.operations.write("is_share", false),
                  Aerospike.operations.write("c_c", 0),
                  Aerospike.operations.write("l_c", 0),
                ],
              });
            }
            // *** Group post meta
            else if (batchArrKeys[i].set === process.env.SET_GROUP_POST_META) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("id", post_id),
                  Aerospike.operations.write("likes", []),
                  Aerospike.operations.write("heart", []),
                  Aerospike.operations.write("haha", []),
                  Aerospike.operations.write("party", []),
                  Aerospike.operations.write("dislikes", []),
                  Aerospike.operations.write("spam", []),
                  Aerospike.operations.write("share", []),
                ],
              });
            }

            // *** Group post comment
            else if (
              batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT
            ) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.operations.write("pid", post_id), // user post list
                ],
              });
            }

            // ***
            else if (batchArrKeys[i].set === process.env.SET_GROUP_META) {
              batchRecords.push({
                type: batchType.BATCH_WRITE,
                key: batchArrKeys[i],
                ops: [
                  Aerospike.lists.append("posts", post_id), // user post list
                ],
              });
            }

            // *** Group post search
            else if (Array.isArray(batchArrKeys[i])) {
              if (batchArrKeys[i].length > 0) {
                if (batchArrKeys[i][0].set === process.env.SET_POSTS_SEARCH) {
                  let batchPolicy = new Aerospike.BatchPolicy({});
                  let exists = await client.batchExists(
                    batchArrKeys[i],
                    batchPolicy
                  );
                  exists.forEach(async (result) => {
                    var pk_word = result.record.key.key; //primary key
                    var shortKey = pk_word.slice(0, 2).toLowerCase();
                    // var timestmp = new Date().getTime().toString()
                    var pid = `${post_id}`; //post id to append
                    if (req.query.flwr_count > 0) {
                      console.log("Celb");
                      if (result.status !== 0) {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            Aerospike.operations.write("p_k", pk_word),
                            Aerospike.operations.write("f_t", shortKey),
                            Aerospike.operations.write("celb_c", 1),
                            Aerospike.lists.append("celb_p_l", pid), // user post list
                          ],
                        });
                      } else {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            //if exists, append
                            Aerospike.lists.append("celb_p_l", pid),
                            Aerospike.operations.incr("celb_c", 1),
                          ],
                        });
                      }
                    } else {
                      console.log("Normal");
                      if (result.status !== 0) {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            Aerospike.operations.write("p_k", pk_word),
                            Aerospike.operations.write("f_t", shortKey),
                            Aerospike.operations.write("u_c", 1),
                            Aerospike.lists.append("u_p_l", pid), // user post list
                          ],
                        });
                      } else {
                        batchRecords.push({
                          type: batchType.BATCH_WRITE,
                          key: result.record.key,
                          ops: [
                            //if exists, append
                            Aerospike.lists.append("u_p_l", pid),
                            Aerospike.operations.incr("u_c", 1),
                          ],
                        });
                      }
                    }
                  });
                }
              }
            }
          }
          await client.batchWrite(batchRecords, batchPolicy1);
          try {
            var getPostData = await client.get(post_key);
            return res.status(201).json(getPostData.bins);
          } catch (err) {
            return res.status(400).json({ msg: err.message });
          }
        });

        blobStream.end(req.file.buffer);
      }
    }
  }
});

router.post("/donate/:id", async (req, res) => {
  const client = await getAerospikeClient();
  const id = req.params.id;
  console.log(req.query);
  if (!id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      id
    );
    client.exists(post_meta_key, async (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        if (!result) {
          return res.status(400).json({ msg: "No post found" });
        } else {
          // ** Generating time stamp
          const time = Date.now().toString();
          let record = await client.get(post_meta_key);

          const bins = {
            id: time,
            amount: req.query.amount,
            s_name: `${req.user.fn} ${req.user.ln}`,
            s_handleUn: req.user.handleUn,
            s_pic: req.user.p_i || "",
            r_username: req.query.handleUn,
            postId: id,
            message: req.query.message || "",
          };
          const earn_key = new Aerospike.Key(
            process.env.CLUSTER_NAME,
            process.env.SET_EARNING,
            time
          );
          const user_meta_key = new Aerospike.Key(
            process.env.CLUSTER_NAME,
            process.env.SET_USER_META,
            req.query.handleUn
          );

          client.put(earn_key, bins, async (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              let record = await client.get(post_meta_key);
              if (record.bins.earn) {
                console.log("Have ", record.bins.earn);
                const ops = [
                  Aerospike.maps
                    .getByKey("earn", time)
                    .andReturn(Aerospike.maps.returnType.KEY_VALUE),
                ];

                client.operate(post_meta_key, ops, async (err, result) => {
                  if (err) {
                    return res.status(400).json({ msg: err.message });
                  } else {
                    if (result.bins.earn[0] === time) {
                      const value =
                        Number(result.bins.earn[1]) + Number(req.query.amount);

                      const ops = [
                        Aerospike.maps.put("earn", time, value, {
                          order: maps.order.KEY_ORDERED,
                        }),
                      ];
                      let data = await client.operate(post_meta_key, ops);
                      try {
                        return res.status(200).json({ msg: "Success" });
                      } catch (error) {
                        return res.status(400).json({ msg: error.message });
                      }
                    } else {
                      const ops = [
                        Aerospike.maps.put("earn", time, req.query.amount, {
                          order: maps.order.KEY_ORDERED,
                        }),
                      ];
                      let result = await client.operate(post_meta_key, ops);
                      try {
                        let result = await client.operate(user_meta_key, ops);
                        try {
                          return res.status(200).json({ msg: "Success" });
                        } catch (error) {
                          return res.status(400).json({ msg: error.message });
                        }
                      } catch (error) {
                        return res.status(400).json({ msg: error.message });
                      }
                    }
                  }
                });
              } else {
                const ops = [
                  Aerospike.maps.put("earn", time, req.query.amount, {
                    order: maps.order.KEY_ORDERED,
                  }),
                ];
                let result = await client.operate(post_meta_key, ops);
                try {
                  let result = await client.operate(user_meta_key, ops);
                  try {
                    return res.status(200).json({ msg: "Success" });
                  } catch (error) {
                    return res.status(400).json({ msg: err.message });
                  }
                } catch (error) {
                  return res.status(400).json({ msg: error.message });
                }
              }
            }
          });
        }
      }
    });
  }
});

router.get("/fetch/analytics/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    console.log(req.params.id);
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      req.params.id
    );

    var post;

    client.exists(post_key, async (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        if (!result) {
          return res.status(400).json({ msg: "Invalid request" });
        } else {
          const mapOps = [
            Aerospike.maps
              .getByKey("analytics", req.query.date)
              .andReturn(maps.returnType.KEY_VALUE),
          ];
          client.operate(post_meta_key, mapOps, async (err, result) => {
            const post = await client.get(post_meta_key);
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res
                .status(200)
                .json({ metaData: post, analytics: result.bins.analytics });
            }
          });
        }
      }
    });
  }
});

//**************** GROUP POST COMMENT **************//

// 1. Create Group Comment
router.post("/comments/:id", multer.single("cmnt_img"), async (req, res) => {
  const id = req.params.id;
  // console.log(commentconfig[0]);
  const comment_id = now.micro();
  let batchPolicy1 = new Aerospike.BatchPolicy({});

  if (!req.params.id) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    const client = await getAerospikeClient();
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_MAIN_GROUP_POST,
      req.params.id
    );
    const post_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const post_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_META,
      req.params.id
    );

    const postData = await client.get(post_key);

    client.exists(post_key, async (err, data) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        if (!data) {
          return res.status(400).json({ msg: "Post id not valid" });
        } else {
          const post_comment_key = new Aerospike.Key(
            process.env.CLUSTER_NAME,
            process.env.SET_GROUP_POST_COMMENT,
            comment_id
          );
          const post_comment_meta_key = new Aerospike.Key(
            process.env.CLUSTER_NAME,
            process.env.SET_GROUP_POST_COMMENT_META,
            comment_id
          );

          const batchType = Aerospike.batchType;
          batchArrKeys = [
            post_comment_key,
            post_comment_meta_key,
            post_key,
            post_feed_key,
            post_meta_key,
          ];
          var batchRecords = [];

          if (!req.file) {
            for (let i = 0; i < batchArrKeys.length; i++) {
              if (batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT) {
                batchRecords.push({
                  type: batchType.BATCH_WRITE,
                  key: batchArrKeys[i],
                  ops: [
                    Aerospike.operations.write("c_id", comment_id), // comment id
                    Aerospike.operations.write("comment", req.body.text),
                    Aerospike.operations.write("gif", req.body.gif || ""),
                    Aerospike.operations.write("postID", req.params.id),
                    Aerospike.operations.write("l_c", 0), // Like count
                    Aerospike.operations.write("d_c", 0), // Dislike count
                    Aerospike.operations.write("s_c", 0), // Spam count
                    Aerospike.operations.write("reply", []), // Reply list
                    Aerospike.operations.write("hide", []), // Hide list
                    Aerospike.operations.write("pinn", false), // Pinn comment
                    Aerospike.operations.write("delete", false), // Delete comment
                    Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                    Aerospike.operations.write(
                      "c_t",
                      new Date().getTime().toString()
                    ), // Comment time
                    Aerospike.operations.write(
                      "u_t",
                      new Date().getTime().toString()
                    ), // Comment update time
                    Aerospike.operations.write("c_fn", req.user.fn),
                    Aerospike.operations.write("c_ln", req.user.ln),
                    Aerospike.operations.write("c_pic", req.user.p_i),
                    Aerospike.operations.write("c_handleUn", req.user.handleUn),
                  ],
                });
              } else if (
                batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT_META
              ) {
                batchRecords.push({
                  type: batchType.BATCH_WRITE,
                  key: batchArrKeys[i],
                  ops: [
                    Aerospike.operations.write("c_m_id", comment_id),
                    Aerospike.operations.write("like", []),
                    Aerospike.operations.write("haha", []),
                    Aerospike.operations.write("angry", []),
                    Aerospike.operations.write("dislikes", []),
                    Aerospike.operations.write("spam", []),
                  ],
                });
              } else if (
                batchArrKeys[i].set === process.env.SET_MAIN_GROUP_POST
              ) {
                batchRecords.push({
                  type: batchType.BATCH_WRITE,
                  key: batchArrKeys[i],
                  ops: [Aerospike.operations.incr("c_c", 1)],
                });
              } else if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
                batchRecords.push({
                  type: batchType.BATCH_WRITE,
                  key: batchArrKeys[i],
                  ops: [Aerospike.operations.incr("c_c", 1)],
                });
              } else {
                batchRecords.push({
                  type: batchType.BATCH_WRITE,
                  key: batchArrKeys[i],
                  ops: [Aerospike.lists.append("cmnt", comment_id)],
                });
              }
            }
            const postedData = await client.batchWrite(
              batchRecords,
              batchPolicy1
            );
            const data = await client.get(post_comment_key);
            if (req.user.handleUn !== postData.bins.u_dun) {
              const map_key = new Aerospike.Key(
                process.env.CLUSTER_NAME,
                process.env.SET_APP_HISTORY,
                postData.bins.u_dun
              );
              var notificationData = {
                id: id,
                ty: 7,
                vi: false,
                wo: req.user.handleUn,
                ti: Date.now(),
                nm: `${req.user.fn} ${req.user.ln}`,
                pi: req.user.p_i,
                re: postData.bins.u_dun,
              };
              const map_ops = [
                Aerospike.operations.write("n_id", postData.bins.u_dun),
                Aerospike.maps.put(
                  "notification",
                  Date.now(),
                  notificationData,
                  {
                    order: maps.order.KEY_ORDERED,
                  }
                ),
                Aerospike.operations.incr("count", 1),
              ];
              let result = await client.operate(map_key, map_ops);
              return res
                .status(201)
                .json({ comment: data, notificationData: notificationData });
            } else {
              return res.status(201).json({ comment: data });
            }
          } else {
            const newImageName = comment_id + "-" + req.file.originalname;
            const blob = bucket.file(newImageName);
            const blobStream = blob.createWriteStream();

            blobStream.on("error", (err) => {
              console.log(err);
              return res.status(400).json({ msg: err.message });
            });

            blobStream.on("finish", async () => {
              var publicURL = `https://storage.googleapis.com/${process.env.GCS_BUCKET}/${blob.name}`;
              console.log(publicURL);
              for (let i = 0; i < batchArrKeys.length; i++) {
                if (
                  batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT
                ) {
                  batchRecords.push({
                    type: batchType.BATCH_WRITE,
                    key: batchArrKeys[i],
                    ops: [
                      Aerospike.operations.write("c_id", comment_id), // comment id
                      Aerospike.operations.write("comment", req.body.text),
                      Aerospike.operations.write("image", publicURL),
                      Aerospike.operations.write("postID", req.params.id),
                      Aerospike.operations.write("l_c", 0), // Like count
                      Aerospike.operations.write("d_c", 0), // Dislike count
                      Aerospike.operations.write("s_c", 0), // Spam count
                      Aerospike.operations.write("reply", []), // Reply list
                      Aerospike.operations.write("hide", []), // Hide list
                      Aerospike.operations.write("pinn", false), // Pinn comment
                      Aerospike.operations.write("delete", false), // Delete comment
                      Aerospike.operations.write("timestamp", Date.now()), //group post timestamp hide
                      Aerospike.operations.write(
                        "c_t",
                        new Date().getTime().toString()
                      ), // Comment time
                      Aerospike.operations.write(
                        "u_t",
                        new Date().getTime().toString()
                      ), // Comment update time
                      Aerospike.operations.write("c_fn", req.user.fn),
                      Aerospike.operations.write("c_ln", req.user.ln),
                      Aerospike.operations.write("c_pic", req.user.p_i),
                      Aerospike.operations.write(
                        "c_handleUn",
                        req.user.handleUn
                      ),
                    ],
                  });
                } else if (
                  batchArrKeys[i].set ===
                  process.env.SET_GROUP_POST_COMMENT_META
                ) {
                  batchRecords.push({
                    type: batchType.BATCH_WRITE,
                    key: batchArrKeys[i],
                    ops: [
                      Aerospike.operations.write("c_m_id", comment_id),
                      Aerospike.operations.write("like", []),
                      Aerospike.operations.write("dislike", []),
                      Aerospike.operations.write("spam", []),
                    ],
                  });
                } else if (
                  batchArrKeys[i].set === process.env.SET_MAIN_GROUP_POST
                ) {
                  batchRecords.push({
                    type: batchType.BATCH_WRITE,
                    key: batchArrKeys[i],
                    ops: [Aerospike.operations.incr("c_c", 1)],
                  });
                } else if (
                  batchArrKeys[i].set === process.env.SET_GROUP_POSTS
                ) {
                  batchRecords.push({
                    type: batchType.BATCH_WRITE,
                    key: batchArrKeys[i],
                    ops: [Aerospike.operations.incr("c_c", 1)],
                  });
                } else {
                  batchRecords.push({
                    type: batchType.BATCH_WRITE,
                    key: batchArrKeys[i],
                    ops: [Aerospike.lists.append("cmnt", comment_id)],
                  });
                }
              }
              const postedData = await client.batchWrite(
                batchRecords,
                batchPolicy1
              );
              const data = await client.get(post_comment_key);
              if (req.user.handleUn !== postData.bins.u_dun) {
                const map_key = new Aerospike.Key(
                  process.env.CLUSTER_NAME,
                  process.env.SET_APP_HISTORY,
                  postData.bins.u_dun
                );
                var notificationData = {
                  id: id,
                  ty: 7,
                  vi: false,
                  wo: req.user.handleUn,
                  ti: Date.now(),
                  nm: `${req.user.fn} ${req.user.ln}`,
                  pi: req.user.p_i,
                  cat: 1,
                  re: postData.bins.u_dun,
                };
                const map_ops = [
                  Aerospike.operations.write("n_id", postData.bins.u_dun),
                  Aerospike.maps.put(
                    "notification",
                    Date.now(),
                    notificationData,
                    {
                      order: maps.order.KEY_ORDERED,
                    }
                  ),
                  Aerospike.operations.incr("count", 1),
                ];
                let result = await client.operate(map_key, map_ops);
                return res
                  .status(201)
                  .json({ comment: data, notificationData: notificationData });
              } else {
                return res.status(201).json({ comment: data });
              }
            });
            blobStream.end(req.file.buffer);
          }
        }
      }
    });
  }
});

router.get("/comments/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid" });
  } else {
    const client = await getAerospikeClient();
    const key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_USER_META,
      req.user.handleUn
    );
    const user_meta = await client.get(key);
    var arr = [];
    var sortedBy = req.query.sortedBy;

    var query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT
    );
    query.where(Aerospike.filter.equal("postID", req.params.id));
    var stream = query.foreach();

    stream.on("data", function (record) {
      // arr.push(data.bins);
      if (req.user.handleUn !== record.bins.c_handleUn) {
        arr.push(record.bins);
      }
    });

    stream.on("end", function (posts) {
      // console.log(sortedBy);
      // arr = arr.sort((a, b) => b.c_id - a.c_id);
      // var page = req.query.page || 1;
      // var limit = req.query.limit || 1;
      // var start = (page - 1) * limit;
      // var end = page * limit;
      // var count = 0;
      // arr = arr.slice(start, end);
      // console.log(arr);
      // return res.status(200).json(arr);
      if (sortedBy === "old") {
        var temp = arr.sort((a, b) => a.c_id - b.c_id);
        const page = req.query.page;
        const limit = req.query.limit;
        const sortedBy = req.query.sortedBy;
        var start = (page - 1) * limit;
        var end = page * limit;
        var data = temp.slice(start, end);
        return res.status(200).json(data);
      } else if (sortedBy === "pop ") {
        var temp = arr.sort((a, b) => b.l_c - a.l_c);
        const page = req.query.page;
        const limit = req.query.limit;
        const sortedBy = req.query.sortedBy;
        var start = (page - 1) * limit;
        var end = page * limit;
        var data = temp.slice(start, end);
        return res.status(200).json(data);
      } else {
        var temp = arr.sort((a, b) => b.c_id - a.c_id);
        const page = req.query.page;
        const limit = req.query.limit;
        const sortedBy = req.query.sortedBy;
        var start = (page - 1) * limit;
        var end = page * limit;
        var data = temp.slice(start, end);
        return res.status(200).json(data);
      }
    });
  }
});

router.get("/my_comments/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid" });
  } else {
    const client = await getAerospikeClient();
    const key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_USER_META,
      req.user.handleUn
    );
    const user_meta = await client.get(key);
    var arr = [];
    var sortedBy = req.query.sortedBy;

    var query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT
    );
    query.where(Aerospike.filter.equal("postID", req.params.id));
    var stream = query.foreach();

    stream.on("data", function (record) {
      // arr.push(data.bins);
      if (req.user.handleUn === record.bins.c_handleUn) {
        arr.push(record.bins);
      }
    });

    stream.on("end", function (posts) {
      // console.log(sortedBy);
      arr = arr.sort((a, b) => b.c_id - a.c_id);
      var page = req.query.page || 1;
      var limit = req.query.limit || 1;
      var start = (page - 1) * limit;
      var end = page * limit;
      var count = 0;
      arr = arr.slice(start, end);
      console.log(arr);
      return res.status(200).json(arr);
    });
  }
});

// 2. Comment Like route
// router.put("/comment/like/:id", async (req, res) => {
//   const commentId = req.params.id;
//   const client = await getAerospikeClient();
//   if (!commentId) {
//     return res.status(401).json({ msg: "Invalid request" });
//   } else {
//     const comment_meta_key = new Aerospike.Key(
//       process.env.CLUSTER_NAME,
//       process.env.SET_GROUP_POST_COMMENT_META,
//       req.params.id
//     );
//     const comment_key = new Aerospike.Key(
//       process.env.CLUSTER_NAME,
//       process.env.SET_GROUP_POST_COMMENT,
//       req.params.id
//     );

//     const data = await client.get(comment_meta_key);
//     const commentData = await client.get(comment_key);
//     const metaData = data.bins;
//     if (metaData.dislike.includes(req.user.handleUn)) {
//       console.log("already dislike");
//       const ops = [
//         Aerospike.lists.removeByValue("dislike", req.user.handleUn),
//         Aerospike.lists.append("like", req.user.handleUn),
//       ];

//       client.operate(comment_meta_key, ops, (err, result) => {
//         if (err) {
//           return res.status(400).json({ msg: err.message });
//         } else {
//           const ops1 = [
//             Aerospike.operations.incr("d_c", -1),
//             Aerospike.operations.incr("l_c", 1),
//           ];
//           client.operate(comment_key, ops1, async (err, result) => {
//             if (err) {
//               return res.status(400).json({ msg: err.message });
//             } else {
//               if (commentData.bins.c_handleUn !== req.user.handleUn) {
//                 const map_key = new Aerospike.Key(
//                   process.env.CLUSTER_NAME,
//                   process.env.SET_APP_HISTORY,
//                   commentData.bins.c_handleUn
//                 );
//                 const map_ops = [
//                   Aerospike.operations.write(
//                     "n_id",
//                     commentData.bins.c_handleUn
//                   ),
//                   Aerospike.maps.put(
//                     "notification",
//                     Date.now(),
//                     {
//                       id: commentData.bins.postID,
//                       ty: 10,
//                       cat: 6,
//                       vi: false,
//                       wo: req.user.handleUn,
//                       ti: Date.now(),
//                       nm: `${req.user.fn} ${req.user.ln}`,
//                       pi: req.user.p_i,
//                       amount: req.query.amount,
//                     },
//                     {
//                       order: maps.order.KEY_ORDERED,
//                     }
//                   ),
//                   Aerospike.operations.incr("count", 1),
//                 ];
//                 let result = await client.operate(map_key, map_ops);
//               }
//               return res
//                 .status(200)
//                 .json({ msg: "Dislike removed and Like added" });
//             }
//           });
//         }
//       });
//     } else {
//       if (metaData.like.includes(req.user.handleUn)) {
//         console.log("Already like");
//         const ops = [Aerospike.lists.removeByValue("like", req.user.handleUn)];
//         client.operate(comment_meta_key, ops, (err, result) => {
//           if (err) {
//             return res.status(400).json({ msg: err.message });
//           } else {
//             const ops1 = [Aerospike.operations.incr("l_c", -1)];
//             client.operate(comment_key, ops1, (err, result) => {
//               if (err) {
//                 return res.status(400).json({ msg: err.message });
//               } else {
//                 return res
//                   .status(200)
//                   .json({ msg: "you remove like from this comment", result });
//               }
//             });
//           }
//         });
//       } else {
//         const ops = [Aerospike.lists.append("like", req.user.handleUn)];
//         client.operate(comment_meta_key, ops, async (err, result) => {
//           if (err) {
//             return res.status(400).json({ msg: err.message });
//           } else {
//             const ops1 = [Aerospike.operations.incr("l_c", 1)];
//             client.operate(comment_key, ops1, async (err, result) => {
//               if (err) {
//                 return res.status(400).json({ msg: err.message });
//               } else {
//                 // console.log(commentData.bins);
//                 // *** save notification data
//                 if (commentData.bins.c_handleUn !== req.user.handleUn) {
//                   const map_key = new Aerospike.Key(
//                     process.env.CLUSTER_NAME,
//                     process.env.SET_APP_HISTORY,
//                     commentData.bins.c_handleUn
//                   );
//                   const map_ops = [
//                     Aerospike.operations.write(
//                       "n_id",
//                       commentData.bins.c_handleUn
//                     ),
//                     Aerospike.maps.put(
//                       "notification",
//                       Date.now(),
//                       {
//                         id: commentData.bins.postID,
//                         ty: 10,
//                         cat: 6,
//                         vi: false,
//                         wo: req.user.handleUn,
//                         ti: Date.now(),
//                         nm: `${req.user.fn} ${req.user.ln}`,
//                         pi: req.user.p_i,
//                         amount: req.query.amount,
//                       },
//                       {
//                         order: maps.order.KEY_ORDERED,
//                       }
//                     ),
//                     Aerospike.operations.incr("count", 1),
//                   ];
//                   let result = await client.operate(map_key, map_ops);
//                 }
//                 return res
//                   .status(200)
//                   .json({ msg: "you liked this comment", result });
//               }
//             });
//           }
//         });
//       }
//     }
//   }
// });

// 3. Comment Dislike route
// router.put("/comment/dislike/:id", async (req, res) => {
//   const commentId = req.params.id;
//   const client = await getAerospikeClient();
//   if (!commentId) {
//     return res.status(401).json({ msg: "Invalid request" });
//   } else {
//     const comment_meta_key = new Aerospike.Key(
//       process.env.CLUSTER_NAME,
//       process.env.SET_GROUP_POST_COMMENT_META,
//       req.params.id
//     );
//     const comment_key = new Aerospike.Key(
//       process.env.CLUSTER_NAME,
//       process.env.SET_GROUP_POST_COMMENT,
//       req.params.id
//     );

//     const data = await client.get(comment_meta_key);
//     const metaData = data.bins;
//     const commentData = await client.get(comment_key);

//     if (metaData.like.includes(req.user.handleUn)) {
//       const ops = [
//         Aerospike.lists.removeByValue("like", req.user.handleUn),
//         Aerospike.lists.append("dislike", req.user.handleUn),
//       ];

//       client.operate(comment_meta_key, ops, async (err, result) => {
//         if (err) {
//           return res.status(400).json({ msg: err.message });
//         } else {
//           const ops1 = [
//             Aerospike.operations.incr("l_c", -1),
//             Aerospike.operations.incr("d_c", 1),
//           ];
//           client.operate(comment_key, ops1, async (err, result) => {
//             if (err) {
//               return res.status(400).json({ msg: err.message });
//             } else {
//               return res
//                 .status(200)
//                 .json({ msg: "Like removed and Dislike added" });
//             }
//           });
//         }
//       });
//     } else {
//       if (metaData.dislike.includes(req.user.handleUn)) {
//         console.log("Already dislike");
//         const ops = [
//           Aerospike.lists.removeByValue("dislike", req.user.handleUn),
//         ];
//         client.operate(comment_meta_key, ops, (err, result) => {
//           if (err) {
//             return res.status(400).json({ msg: err.message });
//           } else {
//             const ops1 = [Aerospike.operations.incr("d_c", -1)];
//             client.operate(comment_key, ops1, async (err, result) => {
//               if (err) {
//                 return res.status(400).json({ msg: err.message });
//               } else {
//                 // *** save notification data
//                 if (commentData.bins.c_handleUn !== req.user.handleUn) {
//                   const map_key = new Aerospike.Key(
//                     process.env.CLUSTER_NAME,
//                     process.env.SET_APP_HISTORY,
//                     commentData.bins.c_handleUn
//                   );
//                   const map_ops = [
//                     Aerospike.operations.write(
//                       "n_id",
//                       commentData.bins.c_handleUn
//                     ),
//                     Aerospike.maps.put(
//                       "notification",
//                       Date.now(),
//                       {
//                         id: commentData.bins.postID,
//                         ty: 10,
//                         cat: 7,
//                         vi: false,
//                         wo: req.user.handleUn,
//                         ti: Date.now(),
//                         nm: `${req.user.fn} ${req.user.ln}`,
//                         pi: req.user.p_i,
//                         amount: req.query.amount,
//                       },
//                       {
//                         order: maps.order.KEY_ORDERED,
//                       }
//                     ),
//                     Aerospike.operations.incr("count", 1),
//                   ];
//                   let result = await client.operate(map_key, map_ops);
//                 }
//                 return res.status(200).json({
//                   msg: "you remove dislike from this comment",
//                   result,
//                 });
//               }
//             });
//           }
//         });
//       } else {
//         const ops = [Aerospike.lists.append("dislike", req.user.handleUn)];
//         client.operate(comment_meta_key, ops, async (err, result) => {
//           if (err) {
//             return res.status(400).json({ msg: err.message });
//           } else {
//             const ops1 = [Aerospike.operations.incr("d_c", 1)];
//             client.operate(comment_key, ops1, async (err, result) => {
//               if (err) {
//                 return res.status(400).json({ msg: err.message });
//               } else {
//                 // *** save notification data
//                 if (commentData.bins.c_handleUn !== req.user.handleUn) {
//                   const map_key = new Aerospike.Key(
//                     process.env.CLUSTER_NAME,
//                     process.env.SET_APP_HISTORY,
//                     commentData.bins.c_handleUn
//                   );
//                   const map_ops = [
//                     Aerospike.operations.write(
//                       "n_id",
//                       commentData.bins.c_handleUn
//                     ),
//                     Aerospike.maps.put(
//                       "notification",
//                       Date.now(),
//                       {
//                         id: commentData.bins.postID,
//                         ty: 10,
//                         cat: 7,
//                         vi: false,
//                         wo: req.user.handleUn,
//                         ti: Date.now(),
//                         nm: `${req.user.fn} ${req.user.ln}`,
//                         pi: req.user.p_i,
//                         amount: req.query.amount,
//                       },
//                       {
//                         order: maps.order.KEY_ORDERED,
//                       }
//                     ),
//                     Aerospike.operations.incr("count", 1),
//                   ];
//                   let result = await client.operate(map_key, map_ops);
//                 }
//                 return res
//                   .status(200)
//                   .json({ msg: "you disliked this comment", result });
//               }
//             });
//           }
//         });
//       }
//     }
//   }
// });

router.put("/comment/:type/:id/:username/:likeCount", async (req, res) => {
  if (!req.params.id || !req.params.username || !req.params.type) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    console.log(req.params.type);
    var batchRecords = [];
    const batchType = Aerospike.batchType;
    const client = await getAerospikeClient();
    const post_comment_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT,
      req.params.id
    );

    const post_comment_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT_META,
      req.params.id
    );

    let batchPolicy1 = new Aerospike.BatchPolicy({});
    var batchArrKeys = [post_comment_key, post_comment_meta_key];

    const commentData = await client.get(post_comment_key);
    const commentMetaData = await client.get(post_comment_meta_key);

    var commentOps;
    var commentMetaOps;

    if (req.params.type === "like") {
      console.log("## LIKE ##");
      if (commentData.bins.l_c > 0) {
        if (commentMetaData.bins.likes.includes(req.user.handleUn)) {
          commentOps = [Aerospike.operations.incr("l_c", -1)];
          commentMetaOps = [
            Aerospike.lists.removeByValue("likes", req.user.handleUn),
          ];
        } else {
          commentOps = [Aerospike.operations.incr("l_c", 1)];
          commentMetaOps = [Aerospike.lists.append("likes", req.user.handleUn)];
        }
      } else {
        commentOps = [Aerospike.operations.incr("l_c", 1)];
        commentMetaOps = [Aerospike.lists.append("likes", req.user.handleUn)];
      }
    } else if (req.params.type === "dislike") {
      if (commentData.bins.l_c > 0) {
        if (commentMetaData.bins.dislikes.includes(req.user.handleUn)) {
          commentOps = [Aerospike.operations.incr("l_c", -1)];
          commentMetaOps = [
            Aerospike.lists.removeByValue("dislikes", req.user.handleUn),
          ];
        } else {
          commentOps = [Aerospike.operations.incr("l_c", 1)];
          commentMetaOps = [
            Aerospike.lists.append("dislikes", req.user.handleUn),
          ];
        }
      } else {
        commentOps = [Aerospike.operations.incr("l_c", 1)];
        commentMetaOps = [
          Aerospike.lists.append("dislikes", req.user.handleUn),
        ];
      }
    } else if (req.params.type === "haha") {
      console.log("## HAHA ##");
      if (Number(req.params.likeCount) > 0) {
        if (commentMetaData.bins.haha.includes(req.user.handleUn)) {
          commentOps = [Aerospike.operations.incr("l_c", -1)];
          commentMetaOps = [
            Aerospike.lists.removeByValue("haha", req.user.handleUn),
          ];
        } else {
          commentOps = [Aerospike.operations.incr("l_c", 1)];
          commentMetaOps = [Aerospike.lists.append("haha", req.user.handleUn)];
        }
      } else {
        commentOps = [Aerospike.operations.incr("l_c", 1)];
        commentMetaOps = [Aerospike.lists.append("haha", req.user.handleUn)];
      }
    } else if (req.params.type === "angry") {
      if (Number(req.params.likeCount) > 0) {
        if (commentMetaData.bins.haha.includes(req.user.handleUn)) {
          commentOps = [Aerospike.operations.incr("l_c", -1)];
          commentMetaOps = [
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
          ];
        } else {
          commentOps = [Aerospike.operations.incr("l_c", 1)];
          commentMetaOps = [Aerospike.lists.append("angry", req.user.handleUn)];
        }
      } else {
        commentOps = [Aerospike.operations.incr("l_c", 1)];
        commentMetaOps = [Aerospike.lists.append("angry", req.user.handleUn)];
      }
    }

    for (let i = 0; i < batchArrKeys.length; i++) {
      if (batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT) {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: commentOps,
        });
      } else {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: commentMetaOps,
        });
      }
    }

    await client.batchWrite(batchRecords, batchPolicy1);
    try {
      console.log("Complete HERE ***");
      // return res.status(200).json({ msg: "Complete" });
      if (req.params.username !== req.user.handleUn) {
        const map_key = new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.SET_APP_HISTORY,
          req.params.username
        );
        const notificationData = {
          id: commentData.bins.postId,
          ty: 8,
          vi: false,
          wo: req.user.handleUn,
          ti: Date.now(),
          nm: `${req.user.fn} ${req.user.ln}`,
          pi: req.user.p_i,
          cat: 4,
          re: req.params.username,
        };
        const map_ops = [
          Aerospike.operations.write("n_id", req.params.username),
          Aerospike.maps.put("notification", Date.now(), notificationData, {
            order: maps.order.KEY_ORDERED,
          }),
          Aerospike.operations.incr("count", 1),
        ];
        let result = await client.operate(map_key, map_ops);
        return res.status(200).json({
          msg: `You reacted ${req.params.type} on this comment`,
          notificationData,
        });
      } else {
        return res
          .status(200)
          .json({ msg: `You reacted ${req.params.type} on this comment` });
      }
    } catch (error) {
      return res.status(400).json({ msg: "Something went wrong" });
    }
  }
});

router.post("/comment/like/remove/:id", async (req, res) => {
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid parameter" });
  } else {
    var batchRecords = [];
    const batchType = Aerospike.batchType;
    const client = await getAerospikeClient();
    const post_comment_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT,
      req.params.id
    );

    const post_comment_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT_META,
      req.params.id
    );

    let batchPolicy1 = new Aerospike.BatchPolicy({});
    var batchArrKeys = [post_comment_key, post_comment_meta_key];

    for (let i = 0; i < batchArrKeys.length; i++) {
      if (batchArrKeys[i].set === process.env.SET_GROUP_POST_COMMENT) {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: [Aerospike.operations.incr("l_c", -1)],
        });
      } else {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: [
            Aerospike.lists.removeByValue("likes", req.user.handleUn),
            Aerospike.lists.removeByValue("dislikes", req.user.handleUn),
            Aerospike.lists.removeByValue("haha", req.user.handleUn),
            Aerospike.lists.removeByValue("angry", req.user.handleUn),
          ],
        });
      }
    }

    await client.batchWrite(batchRecords, batchPolicy1);
    try {
      return res.status(200).json({ msg: "Emoji reaction remove" });
    } catch (error) {
      return res.status(400).json({ msg: error.message });
    }
  }
});

// Comment Report router
router.put("/comment/spam/:id", async (req, res) => {
  const commentId = req.params.id;
  const client = await getAerospikeClient();
  if (!commentId) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    const comment_meta_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT_META,
      req.params.id
    );
    const comment_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT,
      req.params.id
    );

    const data = await client.get(comment_meta_key);
    const metaData = data.bins;

    if (metaData.spam.includes(req.user.handleUn)) {
      const ops = [Aerospike.lists.removeByValue("spam", req.user.handleUn)];
      client.operate(comment_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops1 = [Aerospike.operations.incr("s_c", -1)];
          client.operate(comment_key, ops1, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res.status(200).json({ msg: "spam removed" });
            }
          });
        }
      });
    } else {
      const ops = [Aerospike.lists.append("spam", req.user.handleUn)];
      client.operate(comment_meta_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          const ops1 = [Aerospike.operations.incr("s_c", 1)];
          client.operate(comment_key, ops1, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res.status(200).json({ msg: "spam added" });
            }
          });
        }
      });
    }
  }
});

// 4. Pinned Comment
router.put("/comment/pinned/:id", async (req, res) => {
  const postId = req.body.postId;
  const commentId = req.params.id;
  const client = await getAerospikeClient();
  if (!postId || !commentId) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POST_COMMENT,
      postId
    );
    const postData = await client.get(post_key);
    // console.log(postData.bins);
    const comment_pinned_ops = [
      Aerospike.maps
        .getByKey("comments", commentId.toString())
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(post_key, comment_pinned_ops, (err, result) => {
      if (err) {
        return res.status(401).json({ msg: err.message });
      } else {
        // console.log(result.bins)
        if (!result.bins.comments.pinned) {
          console.log("Pinned set to false");
          result.bins.comments.pinned = true;
          const post_comment_ops = [
            Aerospike.maps.put("comments", commentId, result.bins.comments),
          ];

          client.operate(post_key, post_comment_ops, async (err, result) => {
            if (err) {
              return res.status(401).json({ msg: err.message });
            } else {
              const postData = await client.get(post_key);
              // console.log(postData.bins);
              return res
                .status(200)
                .json({ msg: "You pinned this comment", post: postData.bins });
            }
          });
        } else {
          console.log("Pinned set to true");
          result.bins.comments.pinned = false;
          const post_comment_ops = [
            Aerospike.maps.put("comments", commentId, result.bins.comments),
          ];

          client.operate(post_key, post_comment_ops, async (err, result) => {
            if (err) {
              return res.status(401).json({ msg: err.message });
            } else {
              const postData = await client.get(post_key);
              // console.log(postData.bins);
              return res.status(200).json({
                msg: "You unpinned this comment",
                post: postData.bins,
              });
            }
          });
        }
      }
    });
  }
});

// 6. Edit  comment
router.put("/comment/edit/:id", multer.single("img"), async (req, res) => {
  const commentId = req.params.id;
  const client = await getAerospikeClient();
  const key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POST_COMMENT,
    commentId
  );

  client.exists(key, async (err, data) => {
    if (err) {
      return res.status(400).json({ msg: err.message });
    } else {
      if (!data) {
        return res.status(400).json({ msg: "No comment found" });
      } else {
        const ops = [Aerospike.operations.write("comment", req.body.message)];
        const data = await client.operate(key, ops);
        try {
          return res.status(400).json({ msg: "Comment updated" });
        } catch (err) {
          return res.status(400).json({ msg: err.message });
        }
      }
    }
  });
});

// 7. Delete Comment
router.put("/comment/delete/:id", async (req, res) => {
  const commentId = req.params.id;
  const client = await getAerospikeClient();
  const key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POST_COMMENT,
    commentId
  );

  client.exists(key, async (err, data) => {
    if (err) {
      return res.status(400).json({ msg: err.message });
    } else {
      if (!data) {
        return res.status(400).json({ msg: "No comment found" });
      } else {
        const data = await client.get(key);
        const postId = data.bins.postID;
        const post_key = new Aerospike.Key(
          process.env.CLUSTER_NAME,
          process.env.SET_MAIN_GROUP_POST,
          postId
        );
        const post_ops = [Aerospike.operations.incr("c_c", -1)];
        const ops = [Aerospike.operations.write("delete", true)];
        client.operate(key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            client.operate(post_key, post_ops, (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                return res
                  .status(200)
                  .json({ msg: "Comment has been deleted" });
              }
            });
          }
        });
      }
    }
  });
});

// 8. Hide comment
router.put("/comment/hide/:id", async (req, res) => {
  const commentId = req.params.id;
  const client = await getAerospikeClient();
  const key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POST_COMMENT,
    commentId
  );

  client.exists(key, async (err, data) => {
    if (err) {
      return res.status(400).json({ msg: err.message });
    } else {
      if (!data) {
        return res.status(400).json({ msg: "No comment found" });
      } else {
        const data = await client.get(key);
        if (data.bins.hide.includes(req.user.handleUn)) {
          console.log("Already hide");
          const ops = [
            Aerospike.lists.removeByValue("hide", req.user.handleUn),
          ];
          client.operate(key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: "err.message" });
            } else {
              return res.status(200).json({ msg: "You unhide this comment" });
            }
          });
        } else {
          const ops = [Aerospike.lists.append("hide", req.user.handleUn)];
          client.operate(key, ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: "err.message" });
            } else {
              return res.status(200).json({ msg: "You hide this comment" });
            }
          });
        }
      }
    }
  });
});

// 9. POST COMMENT REPORT
router.put("/comment/report/:id", async (req, res) => {
  const commentId = req.params.id;
  if (!commentId) {
    return res.status(401).json({ msg: "Invalid request" });
  } else {
    var comment = await GroupPostComment.findById(commentId);
    if (!comment) {
      return res.status(401).json({ msg: "Invalid comment" });
    } else {
      const newReport = Group_Comment_Report({
        _id: new mongoose.Types.ObjectId(),
        userId: req.user._id,
        commentId: commentId,
        report_types: req.body.list,
      });
      newReport
        .save()
        .then(async (report) => {
          comment = await GroupPostComment(
            comment,
            { $addToSet: { report: report._id } },
            { new: true }
          );
          return res.status(200).json({ msg: "Your report has been submited" });
        })
        .catch((err) => {
          return res.status(501).json({ msg: err.message });
        });
    }
  }
});

// ******* CREATE GROUP COMMENT REPLY
router.post("/comment/reply/:id", async (req, res) => {
  const client = await getAerospikeClient();
  const commentId = req.params.id;
  const reply_id = now.micro();
  const reply_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    "comment_reply",
    req.params.id
  );
  const post_comment_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POST_COMMENT,
    commentId
  );

  const reply_bins = {
    id: reply_id,
    content: req.body.content,
    l_c: 0, // Like counter
    d_c: 0, // Dislike counter
    s_c: 0, // Spam counter
    c_t: new Date().getTime().toString(),
    u_t: new Date().getTime().toString(),
    timestamp: Date.now(),
    hides: [], // Hides
    delete: false,
    c_u_fn: req.user.firstName,
    c_u_ln: req.user.lastName,
    c_u_du: req.user.handleUn,
    c_u_img: req.user.p_i,
  };

  const reply_meta_bins = {
    likes: [],
    dislikes: [],
    spam: [],
  };
  const post_comment_ops = [
    Aerospike.maps.put("replies", reply_id, reply_bins),
    Aerospike.maps.put("replies_meta", reply_id, reply_meta_bins),
  ];

  client.operate(reply_key, post_comment_ops, (err, result) => {
    if (err) {
      return res.status(400).json({ msg: err.message });
    } else {
      console.log("Reply saved");
      const get_post_comment_ops = [
        Aerospike.maps
          .getByKey("replies", reply_id)
          .andReturn(maps.returnType.VALUE),
      ];

      const ops = [
        Aerospike.maps
          .getByKey("comments", commentId)
          .andReturn(maps.returnType.VALUE),
      ];
      client.operate(post_comment_key, ops, (err, result) => {
        if (err) {
          return res.status(400).json({ msg: err.message });
        } else {
          result.bins.comments.r_c = result.bins.comments.r_c + 1;
          const cmnt_ops = [
            Aerospike.maps.put("comments", commentId, result.bins.comments),
          ];
          client.operate(post_comment_key, cmnt_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(reply_key, get_post_comment_ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  return res.status(200).json(result.bins);
                }
              });
            }
          });
        }
      });
    }
  });
});

// *** Fetch all replies
router.get("/comment/reply/:id", async (req, res) => {
  const client = await getAerospikeClient();
  // commentId == req.params.id
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const reply_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      req.params.id
    );
    const replyData = await client.get(reply_key);
    var page = req.query.page;
    var limit = 3;
    var start = (page - 1) * limit;
    var end = page * limit;
    var arr = [];
    var commentData = [];
    for (i in replyData.bins.replies) {
      arr.push(replyData.bins.replies[i]);
    }
    if (page <= limit) {
      commentData = arr.slice(start, end);
    }
    return res.status(200).json(commentData);
  }
});

// *** Group comment reply HIDE
router.put("/comment/reply/hide/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const replyId = req.params.id;
    const commentId = req.body.commentId;
    const client = await getAerospikeClient();
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      commentId
    );
    const comment_hide_ops = [
      Aerospike.maps
        .getByKey("replies", replyId)
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(post_key, comment_hide_ops, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        if (!result.bins.replies.hides.includes(req.user.handleUn)) {
          result.bins.replies.hides.push(req.user.handleUn);

          const reply_hide_ops = [
            Aerospike.maps.put("replies", replyId, result.bins.replies),
          ];

          client.operate(post_key, reply_hide_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res.status(200).json({ msg: "you hide this reply" });
            }
          });
        } else {
          const index = result.bins.replies.hides.indexOf(
            req.user._id.toString()
          );
          result.bins.replies.hides.splice(index, 1);
          const reply_hide_ops = [
            Aerospike.maps.put("replies", replyId, result.bins.replies),
          ];
          client.operate(post_key, reply_hide_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res.status(200).json({ msg: "you unhide this reply" });
            }
          });
        }
      }
    });
  }
});

// *** Group comment reply PINNED
router.put("/comment/reply/delete/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const replyId = req.params.id;
    const commentId = req.body.commentId;
    const client = await getAerospikeClient();
    const post_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      commentId
    );
    const comment_hide_ops = [
      Aerospike.maps
        .getByKey("replies", replyId)
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(post_key, comment_hide_ops, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        if (!result.bins.replies.delete) {
          result.bins.replies.delete = true;

          const post_comment_ops = [
            Aerospike.maps.put("replies", replyId, result.bins.replies),
          ];

          client.operate(post_key, post_comment_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              return res.status(200).json({ msg: "you delete this reply" });
            }
          });
        }
      }
    });
  }
});

// *** Group comment reply LIKE
router.put("/comment/reply/like/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const replyId = req.params.id;
    const commentId = req.body.commentId;
    const client = await getAerospikeClient();
    const reply_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      commentId
    );
    const reply_data = [
      Aerospike.maps
        .getByKey("replies", replyId)
        .andReturn(maps.returnType.VALUE),
    ];
    const reply_meta = [
      Aerospike.maps
        .getByKey("replies_meta", replyId)
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(reply_key, reply_meta, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        const dislikesArr = result.bins.replies_meta.dislikes;
        const likesArr = result.bins.replies_meta.likes;
        console.log(result.bins.replies_meta);
        if (dislikesArr.includes(req.user.handleUn)) {
          console.log("Already dislikes");
          var index = result.bins.replies_meta.dislikes.indexOf(
            req.user.handleUn
          );
          result.bins.replies_meta.dislikes.splice(index, 1);
          result.bins.replies_meta.likes.push(req.user.handleUn);
          const reply_meta_ops = [
            Aerospike.maps.put(
              "replies_meta",
              replyId,
              result.bins.replies_meta
            ),
          ];

          client.operate(reply_key, reply_meta_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(reply_key, reply_data, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  result.bins.replies.l_c = result.bins.replies.l_c + 1;
                  result.bins.replies.d_c = result.bins.replies.d_c - 1;
                  const ops = [
                    Aerospike.maps.put("replies", replyId, result.bins.replies),
                  ];
                  client.operate(reply_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res.status(200).json({ msg: "Like added" });
                    }
                  });
                }
              });
            }
          });
        } else {
          if (result.bins.replies_meta.likes.includes(req.user.handleUn)) {
            console.log("Remove like");
            var index = result.bins.replies_meta.likes.indexOf(
              req.user.handleUn
            );
            result.bins.replies_meta.likes.splice(index, 1);
            const reply_ops = [
              Aerospike.maps.put(
                "replies_meta",
                replyId,
                result.bins.replies_meta
              ),
            ];

            client.operate(reply_key, reply_ops, (err, result) => {
              if (err) {
                return res.status(401).json({ msg: err.message });
              } else {
                client.operate(reply_key, reply_data, (err, result) => {
                  if (err) {
                    return res.sendStatus(400).json({ msg: err.message });
                  } else {
                    result.bins.replies.l_c = result.bins.replies.l_c - 1;
                    const ops = [
                      Aerospike.maps.put(
                        "replies",
                        replyId,
                        result.bins.replies
                      ),
                    ];
                    client.operate(reply_key, ops, (err, result) => {
                      if (err) {
                        return res.status(400).json({ msg: err.message });
                      } else {
                        return res.status(200).json({ msg: "Like remove" });
                      }
                    });
                  }
                });
              }
            });
          } else {
            console.log("Add like");
            result.bins.replies_meta.likes.push(req.user.handleUn);
            const reply_meta_ops = [
              Aerospike.maps.put(
                "replies_meta",
                replyId,
                result.bins.replies_meta
              ),
            ];
            client.operate(reply_key, reply_meta_ops, (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                client.operate(reply_key, reply_data, (err, result) => {
                  if (err) {
                    return res.status(400).json({ msg: err.message });
                  } else {
                    result.bins.replies.l_c = result.bins.replies.l_c + 1;
                    const ops = [
                      Aerospike.maps.put(
                        "replies",
                        replyId,
                        result.bins.replies
                      ),
                    ];
                    client.operate(reply_key, ops, (err, result) => {
                      if (err) {
                        return res.status(400).json({ msg: err.message });
                      } else {
                        return res.status(200).json({ msg: "Like added" });
                      }
                    });
                  }
                });
              }
            });
          }
        }
      }
    });
  }
});

// *** Group comment reply DISLIKE
router.put("/comment/reply/dislike/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const replyId = req.params.id;
    const commentId = req.body.commentId;
    const client = await getAerospikeClient();
    const reply_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      commentId
    );
    const reply_data = [
      Aerospike.maps
        .getByKey("replies", replyId)
        .andReturn(maps.returnType.VALUE),
    ];
    const reply_meta = [
      Aerospike.maps
        .getByKey("replies_meta", replyId)
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(reply_key, reply_meta, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        const dislikesArr = result.bins.replies_meta.dislikes;
        const likesArr = result.bins.replies_meta.likes;
        if (likesArr.includes(req.user.handleUn)) {
          console.log("Already likes");
          var index = result.bins.replies_meta.likes.indexOf(req.user.handleUn);
          result.bins.replies_meta.likes.splice(index, 1);
          result.bins.replies_meta.dislikes.push(req.user.handleUn);
          const reply_meta_ops = [
            Aerospike.maps.put(
              "replies_meta",
              replyId,
              result.bins.replies_meta
            ),
          ];

          client.operate(reply_key, reply_meta_ops, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(reply_key, reply_data, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  result.bins.replies.l_c = result.bins.replies.l_c - 1;
                  result.bins.replies.d_c = result.bins.replies.d_c + 1;
                  const ops = [
                    Aerospike.maps.put("replies", replyId, result.bins.replies),
                  ];
                  client.operate(reply_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res.status(200).json({ msg: "Like added" });
                    }
                  });
                }
              });
            }
          });
        } else {
          if (result.bins.replies_meta.dislikes.includes(req.user.handleUn)) {
            console.log("Remove like");
            var index = result.bins.replies_meta.dislikes.indexOf(
              req.user.handleUn
            );
            result.bins.replies_meta.dislikes.splice(index, 1);
            const reply_ops = [
              Aerospike.maps.put(
                "replies_meta",
                replyId,
                result.bins.replies_meta
              ),
            ];

            client.operate(reply_key, reply_ops, (err, result) => {
              if (err) {
                return res.status(401).json({ msg: err.message });
              } else {
                client.operate(reply_key, reply_data, (err, result) => {
                  if (err) {
                    return res.sendStatus(400).json({ msg: err.message });
                  } else {
                    result.bins.replies.l_c = result.bins.replies.d_c - 1;
                    const ops = [
                      Aerospike.maps.put(
                        "replies",
                        replyId,
                        result.bins.replies
                      ),
                    ];
                    client.operate(reply_key, ops, (err, result) => {
                      if (err) {
                        return res.status(400).json({ msg: err.message });
                      } else {
                        return res.status(200).json({ msg: "DisLike remove" });
                      }
                    });
                  }
                });
              }
            });
          } else {
            console.log("Add like");
            result.bins.replies_meta.dislikes.push(req.user.handleUn);
            const reply_meta_ops = [
              Aerospike.maps.put(
                "replies_meta",
                replyId,
                result.bins.replies_meta
              ),
            ];
            client.operate(reply_key, reply_meta_ops, (err, result) => {
              if (err) {
                return res.status(400).json({ msg: err.message });
              } else {
                client.operate(reply_key, reply_data, (err, result) => {
                  if (err) {
                    return res.status(400).json({ msg: err.message });
                  } else {
                    result.bins.replies.l_c = result.bins.replies.d_c + 1;
                    const ops = [
                      Aerospike.maps.put(
                        "replies",
                        replyId,
                        result.bins.replies
                      ),
                    ];
                    client.operate(reply_key, ops, (err, result) => {
                      if (err) {
                        return res.status(400).json({ msg: err.message });
                      } else {
                        return res.status(200).json({ msg: "DisLike added" });
                      }
                    });
                  }
                });
              }
            });
          }
        }
      }
    });
  }
});

router.put("/comment/reply/spam/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const replyId = req.params.id;
    const commentId = req.body.commentId;
    const client = await getAerospikeClient();
    const reply_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      "comment_reply",
      commentId
    );
    const reply_data = [
      Aerospike.maps
        .getByKey("replies", replyId)
        .andReturn(maps.returnType.VALUE),
    ];
    const reply_meta = [
      Aerospike.maps
        .getByKey("replies_meta", replyId)
        .andReturn(maps.returnType.VALUE),
    ];

    client.operate(reply_key, reply_meta, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        const spamArr = result.bins.replies_meta.spam;
        console.log(result.bins.replies_meta.spam);
        // console.log(spamArr)
        if (spamArr.includes(req.user.handleUn)) {
          console.log("Already spammed");
          const index = result.bins.replies_meta.spam.indexOf(
            req.user.handleUn
          );
          result.bins.replies_meta.spam.splice(index, 1);
          const spam_reply_meta = [
            Aerospike.maps.put(
              "replies_meta",
              replyId,
              result.bins.replies_meta
            ),
          ];

          client.operate(reply_key, spam_reply_meta, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(reply_key, reply_data, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  result.bins.replies.s_c = result.bins.replies.s_c - 1;
                  const reply = [
                    Aerospike.maps.put("replies", replyId, result.bins.replies),
                  ];
                  client.operate(reply_key, reply, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "You remove from spammed" });
                    }
                  });
                }
              });
            }
          });
        } else {
          result.bins.replies_meta.spam.push(req.user.handleUn);
          const reply_meta = [
            Aerospike.maps.put(
              "replies_meta",
              replyId,
              result.bins.replies_meta
            ),
          ];
          client.operate(reply_key, reply_meta, (err, result) => {
            if (err) {
              return res.status(400).json({ msg: err.message });
            } else {
              client.operate(reply_key, reply_data, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  result.bins.replies.s_c = result.bins.replies.s_c + 1;
                  const reply = [
                    Aerospike.maps.put("replies", replyId, result.bins.replies),
                  ];
                  client.operate(reply_key, reply, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "You marked as spammed" });
                    }
                  });
                }
              });
            }
          });
        }
      }
    });
  }
});

// *** Block Events
router.post("/event/create", multer.single("eventimage"), async (req, res) => {
  const { start, end, title, description, blockId, starttime, endtime } =
    req.body;
  console.log(req.body);
  var batchRecords = [];
  const batchType = Aerospike.batchType;
  let batchPolicy1 = new Aerospike.BatchPolicy({});
  const client = await getAerospikeClient();
  const event_id = now.micro();
  // console.log(req.body);
  const result = new Date(req.body.startdate).getTime() - new Date().getTime();
  var activity;
  if (result < 0) {
    activity = false;
  } else {
    activity = true;
  }
  const event_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_BLOCK_EVENT,
    event_id.toString()
  );
  const post_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_POSTS,
    event_id.toString()
  );
  const group_meta_key = new Aerospike.Key(
    process.env.CLUSTER_NAME,
    process.env.SET_GROUP_META,
    req.body.blockId
  );
  batchArrKeys = [post_key, event_key, group_meta_key];
  if (!req.file) {
    for (let i = 0; i < batchArrKeys.length; i++) {
      if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: [
            Aerospike.operations.write("e_id", event_id),
            Aerospike.operations.write("p_id", event_id),
            Aerospike.operations.write("tit", req.body.title),
            Aerospike.operations.write("des", req.body.description),
            Aerospike.operations.write("type", req.body.type),
            Aerospike.operations.write("link", req.body.link || ""),
            Aerospike.operations.write("s_d", req.body.startdate),
            Aerospike.operations.write("e_d", req.body.enddate),
            Aerospike.operations.write("city", req.body.city),
            Aerospike.operations.write("country", req.body.country),
            Aerospike.operations.write("i_u", []),
            Aerospike.operations.write("n_i_u", []),
            Aerospike.operations.write("j_u", []),
            Aerospike.operations.write("price", req.body.price.toString()),
            Aerospike.operations.write("active", activity),
            Aerospike.operations.write("e_c_img", req.user.p_i),
            Aerospike.operations.write("e_c_fn", req.user.fn),
            Aerospike.operations.write("e_c_ln", req.user.ln),
            Aerospike.operations.write("e_c_dun", req.user.handleUn),
            Aerospike.operations.write("delete", false),
            Aerospike.operations.write("isEvent", true),
            Aerospike.operations.write("b_id", req.body.blockId),
          ],
        });
      } else if (batchArrKeys[i].set === process.env.SET_BLOCK_EVENT) {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: [
            Aerospike.operations.write("e_id", event_id),
            Aerospike.operations.write("tit", req.body.title),
            Aerospike.operations.write("des", req.body.description),
            Aerospike.operations.write("type", req.body.type),
            Aerospike.operations.write("link", req.body.link || ""),
            Aerospike.operations.write("s_d", req.body.startdate),
            Aerospike.operations.write("e_d", req.body.enddate),
            Aerospike.operations.write("city", req.body.city),
            Aerospike.operations.write("country", req.body.country),
            Aerospike.operations.write("i_u", []),
            Aerospike.operations.write("n_i_u", []),
            Aerospike.operations.write("j_u", []),
            Aerospike.operations.write("price", req.body.price.toString()),
            Aerospike.operations.write("active", activity),
            Aerospike.operations.write("e_c_img", req.user.p_i),
            Aerospike.operations.write("e_c_fn", req.user.fn),
            Aerospike.operations.write("e_c_ln", req.user.ln),
            Aerospike.operations.write("e_c_dun", req.user.handleUn),
            Aerospike.operations.write("delete", false),
            Aerospike.operations.write("b_id", req.body.blockId),
          ],
        });
      } else if (batchArrKeys[i].set === process.env.SET_GROUP_META) {
        batchRecords.push({
          type: batchType.BATCH_WRITE,
          key: batchArrKeys[i],
          ops: [Aerospike.lists.append("events", event_id)],
        });
      }
    }
    await client.batchWrite(batchRecords, batchPolicy1);
    const data = await client.get(event_key);
    try {
      return res.status(200).json({ msg: "Event created", event: data.bins });
    } catch (err) {
      return res.status(400).json({ msg: err.message });
    }
  } else {
    const newImageName = req.file.originalname;
    const blob = bucket.file(newImageName);
    const blobStream = blob.createWriteStream();
    blobStream.on("error", (err) => {
      console.log(err);
      return res.status(400).json({ msg: err.message });
    });

    blobStream.on("finish", async () => {
      var publicURL = `https://storage.googleapis.com/${process.env.GCS_BUCKET}/${blob.name}`;
      for (let i = 0; i < batchArrKeys.length; i++) {
        if (batchArrKeys[i].set === process.env.SET_GROUP_POSTS) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("e_id", event_id),
              Aerospike.operations.write("p_id", event_id),
              Aerospike.operations.write("tit", req.body.title),
              Aerospike.operations.write("eventimage", publicURL),
              Aerospike.operations.write("tit", req.body.title),
              Aerospike.operations.write("des", req.body.description),
              Aerospike.operations.write("type", req.body.type),
              Aerospike.operations.write("link", req.body.link || ""),
              Aerospike.operations.write("s_d", req.body.startdate),
              Aerospike.operations.write("e_d", req.body.enddate),
              Aerospike.operations.write("city", req.body.city),
              Aerospike.operations.write("country", req.body.country),
              Aerospike.operations.write("i_u", []),
              Aerospike.operations.write("n_i_u", []),
              Aerospike.operations.write("j_u", []),
              Aerospike.operations.write("price", req.body.price.toString()),
              Aerospike.operations.write("active", activity),
              Aerospike.operations.write("e_c_img", req.user.p_i),
              Aerospike.operations.write("e_c_fn", req.user.fn),
              Aerospike.operations.write("e_c_ln", req.user.ln),
              Aerospike.operations.write("e_c_dun", req.user.handleUn),
              Aerospike.operations.write("delete", false),
              Aerospike.operations.write("isEvent", true),
              Aerospike.operations.write("b_id", req.body.blockId),
            ],
          });
        } else if (batchArrKeys[i].set === process.env.SET_BLOCK_EVENT) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [
              Aerospike.operations.write("e_id", event_id),
              Aerospike.operations.write("eventimage", publicURL),
              Aerospike.operations.write("tit", req.body.title),
              Aerospike.operations.write("des", req.body.description),
              Aerospike.operations.write("type", req.body.type),
              Aerospike.operations.write("link", req.body.link || ""),
              Aerospike.operations.write("s_d", req.body.startdate),
              Aerospike.operations.write("e_d", req.body.enddate),
              Aerospike.operations.write("city", req.body.city),
              Aerospike.operations.write("country", req.body.country),
              Aerospike.operations.write("i_u", []),
              Aerospike.operations.write("n_i_u", []),
              Aerospike.operations.write("j_u", []),
              Aerospike.operations.write("price", req.body.price.toString()),
              Aerospike.operations.write("active", activity),
              Aerospike.operations.write("e_c_img", req.user.p_i),
              Aerospike.operations.write("e_c_fn", req.user.fn),
              Aerospike.operations.write("e_c_ln", req.user.ln),
              Aerospike.operations.write("e_c_dun", req.user.handleUn),
              Aerospike.operations.write("delete", false),
              Aerospike.operations.write("b_id", req.body.blockId),
            ],
          });
        } else if (batchArrKeys[i].set === process.env.SET_GROUP_META) {
          batchRecords.push({
            type: batchType.BATCH_WRITE,
            key: batchArrKeys[i],
            ops: [Aerospike.lists.append("events", event_id)],
          });
        }
      }
      await client.batchWrite(batchRecords, batchPolicy1);
      const data = await client.get(event_key);
      try {
        return res.status(200).json({ msg: "Event created", event: data.bins });
      } catch (err) {
        return res.status(400).json({ msg: err.message });
      }
    });
    blobStream.end(req.file.buffer);
  }
});

router.get("/events/:id", async (req, res) => {
  console.log("call");
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid block id" });
  } else {
    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT
    );
    const tempBin = "ExpVar";
    query.where(Aerospike.filter.equal("b_id", req.params.id));

    // const queryPolicy = new Aerospike.QueryPolicy({});
    const stream = query.foreach();
    var temp = [];
    stream.on("data", async function (record) {
      temp.push(record.bins);
    });
    stream.on("end", async function (record) {
      var page = req.query.page || 1;
      var limit = req.query.limit || 3;
      var start = (page - 1) * limit;
      var end = page * limit;
      var count = 0;

      temp = temp.splice(start, end);
      return res.status(200).json(temp);
    });
  }
});

router.put("/event/interest/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    var event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );
    var event_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const eventData = await client.get(event_key);
    const eventFeedData = await client.get(event_feed_key);
    const ops = [
      Aerospike.lists.removeByValue("n_i_u", req.user.handleUn),
      Aerospike.lists.removeByValue("j_u", req.user.handleUn),
    ];

    client.operate(event_key, ops, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        client.operate(event_feed_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            if (eventData.bins.i_u.includes(req.user.handleUn)) {
              const ops = [
                Aerospike.lists.removeByValue("i_u", req.user.handleUn),
              ];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "interest has been remove", result });
                    }
                  });
                }
              });
            } else {
              const ops = [Aerospike.lists.append("i_u", req.user.handleUn)];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "interest has been set", result });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

router.put("/event/not_interest/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    var event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );
    var event_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const eventData = await client.get(event_key);
    const eventFeedData = await client.get(event_feed_key);
    const ops = [
      Aerospike.lists.removeByValue("i_u", req.user.handleUn),
      Aerospike.lists.removeByValue("j_u", req.user.handleUn),
    ];

    client.operate(event_key, ops, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        client.operate(event_feed_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            if (eventData.bins.n_i_u.includes(req.user.handleUn)) {
              const ops = [
                Aerospike.lists.removeByValue("n_i_u", req.user.handleUn),
              ];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "Not interest has been set", result });
                    }
                  });
                }
              });
            } else {
              const ops = [Aerospike.lists.append("n_i_u", req.user.handleUn)];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "Not interest has been set", result });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

router.put("/event/join/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    var event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );
    var event_feed_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_GROUP_POSTS,
      req.params.id
    );
    const eventData = await client.get(event_key);
    const ops = [
      Aerospike.lists.removeByValue("i_u", req.user.handleUn),
      Aerospike.lists.removeByValue("n_i_u", req.user.handleUn),
    ];

    client.operate(event_key, ops, (err, result) => {
      if (err) {
        return res.status(400).json({ msg: err.message });
      } else {
        client.operate(event_feed_key, ops, (err, result) => {
          if (err) {
            return res.status(400).json({ msg: err.message });
          } else {
            if (eventData.bins.j_u.includes(req.user.handleUn)) {
              const ops = [
                Aerospike.lists.removeByValue("j_u", req.user.handleUn),
              ];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "join has been removed", result });
                    }
                  });
                }
              });
            } else {
              const ops = [Aerospike.lists.append("j_u", req.user.handleUn)];
              client.operate(event_key, ops, (err, result) => {
                if (err) {
                  return res.status(400).json({ msg: err.message });
                } else {
                  client.operate(event_feed_key, ops, (err, result) => {
                    if (err) {
                      return res.status(400).json({ msg: err.message });
                    } else {
                      return res
                        .status(200)
                        .json({ msg: "Join has been set", result });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

router.get("/event/:id", async (req, res) => {
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    var client = await getAerospikeClient();
    const event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );

    const data = await client.get(event_key);
    try {
      return res.status(200).json(data.bins);
    } catch (error) {
      return res.status(400).json({ msg: err.message });
    }
  }
});

router.put("/event/delete/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );

    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT
    );
    const tempBin = "ExpVar"; // this bin is to hold expression read operation output
    query.select(["delete"]); //select single bin
    query.where(Aerospike.filter.equal("e_id", req.params.id));

    // const queryPolicy = new Aerospike.QueryPolicy({});
    const stream = query.foreach();
    stream.on("data", async function (record) {
      var data = record.bins.delete;
      const ops = [Aerospike.operations.write("delete", true)];
      await client.operate(event_key, ops);
    });

    stream.on("end", async function (record) {
      return res.status(200).json({ msg: "Event has been delete" });
    });
  }
});

router.put("/event/edit/:id", async (req, res) => {
  const client = await getAerospikeClient();
  if (!req.params.id) {
    return res.status(400).json({ msg: "Invalid request" });
  } else {
    const event_key = new Aerospike.Key(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT,
      req.params.id
    );

    let query = client.query(
      process.env.CLUSTER_NAME,
      process.env.SET_BLOCK_EVENT
    );
    const tempBin = "ExpVar"; // this bin is to hold expression read operation output
    // query.select(["tit", "des", "s_d", "e_d", "s_t", "e_t", "price"]); //select single bin
    query.where(Aerospike.filter.equal("e_id", req.params.id));

    // const queryPolicy = new Aerospike.QueryPolicy({});
    const stream = query.foreach();
    stream.on("data", async function (record) {
      var data = record.bins;
      // console.log(data)
      if (
        !req.body.title.trim() ||
        !req.body.description.trim() ||
        !req.body.startdate.trim() ||
        !req.body.enddate.trim() ||
        !req.body.starttime.trim() ||
        !req.body.endtime.trim()
      ) {
        return res.status(400).json({ msg: "Invalid request" });
      } else {
        console.log("Body");
        console.log(req.body);

        console.log("END");

        const ops = [
          Aerospike.operations.write("tit", req.body.title),
          Aerospike.operations.write("des", req.body.description),
          Aerospike.operations.write("s_d", req.body.startdate),
          Aerospike.operations.write("e_d", req.body.enddate),
          Aerospike.operations.write("s_t", req.body.starttime),
          Aerospike.operations.write("e_t", req.body.endtime),
          Aerospike.operations.write("price", req.body.price),
        ];
        await client.operate(event_key, ops);
      }
    });

    stream.on("end", async function (record) {
      const data = await client.get(event_key);
      console.log(data.bins);
      return res.status(200).json({ msg: "Event has been updated" });
    });
  }
});
module.exports = router;
